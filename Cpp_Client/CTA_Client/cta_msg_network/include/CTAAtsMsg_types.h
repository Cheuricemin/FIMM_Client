/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef CTAAtsMsg_TYPES_H
#define CTAAtsMsg_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "AtsType_types.h"
#include "AtsGeneral_types.h"


namespace CTAMsg {

struct TradingType {
  enum type {
    Unknown = 0,
    Manual = 1,
    Hitter = 2,
    Contrib = 3,
    Spread = 4,
    ContribHedge = 5,
    Max = 6
  };
};

extern const std::map<int, const char*> _TradingType_VALUES_TO_NAMES;

class MarketMakerMsg;

class IAFutureMsg;

class AtsFutureSpreadMsg;

class KlineConfigMsg;

class TWAPDataMsg;

class KlineDataMsg;

class TurtleAlgoMsg;

class CTAAtsMsg;

typedef struct _MarketMakerMsg__isset {
  _MarketMakerMsg__isset() : Active(false), MMLots(false), MMValo(false), TotalMMBidQty(false), MMBidQty(false), MMAskQty(false), TotalMMAskQty(false), FairPrice(false), Position(false), ConvergeRate(false), MovingAvgRatio(false), RiskReward(false), MinGain(false), MinDepth(false), MaxDepth(false), MaxTickCounter(false), Aggresivity(false), HitterAgg(false), EntrySize(false), MinSizeInc(false), MinSizeDec(false), MaxSize(false), MaxNbOrder(false), Residu(false), MovingAvg(false), MovingVolume(false), TradingImpact2Pos(false), TradingImpactPosLimit(false), TradingImpact(false) {}
  bool Active :1;
  bool MMLots :1;
  bool MMValo :1;
  bool TotalMMBidQty :1;
  bool MMBidQty :1;
  bool MMAskQty :1;
  bool TotalMMAskQty :1;
  bool FairPrice :1;
  bool Position :1;
  bool ConvergeRate :1;
  bool MovingAvgRatio :1;
  bool RiskReward :1;
  bool MinGain :1;
  bool MinDepth :1;
  bool MaxDepth :1;
  bool MaxTickCounter :1;
  bool Aggresivity :1;
  bool HitterAgg :1;
  bool EntrySize :1;
  bool MinSizeInc :1;
  bool MinSizeDec :1;
  bool MaxSize :1;
  bool MaxNbOrder :1;
  bool Residu :1;
  bool MovingAvg :1;
  bool MovingVolume :1;
  bool TradingImpact2Pos :1;
  bool TradingImpactPosLimit :1;
  bool TradingImpact :1;
} _MarketMakerMsg__isset;

class MarketMakerMsg {
 public:

  MarketMakerMsg(const MarketMakerMsg&);
  MarketMakerMsg& operator=(const MarketMakerMsg&);
  MarketMakerMsg() : Active(0), MMLots(0), MMValo(0), TotalMMBidQty(0), MMBidQty(0), MMAskQty(0), TotalMMAskQty(0), FairPrice(0), Position(0), ConvergeRate(0), MovingAvgRatio(0), RiskReward(0), MinGain(0), MinDepth(0), MaxDepth(0), MaxTickCounter(0), Aggresivity(0), HitterAgg(0), EntrySize(0), MinSizeInc(0), MinSizeDec(0), MaxSize(0), MaxNbOrder(0), Residu(0), MovingAvg(0), MovingVolume(0), TradingImpact2Pos(0), TradingImpactPosLimit(0), TradingImpact(0) {
  }

  virtual ~MarketMakerMsg() throw();
  bool Active;
  int32_t MMLots;
  double MMValo;
  int32_t TotalMMBidQty;
  int32_t MMBidQty;
  int32_t MMAskQty;
  int32_t TotalMMAskQty;
  double FairPrice;
  int32_t Position;
  double ConvergeRate;
  double MovingAvgRatio;
  double RiskReward;
  double MinGain;
  int32_t MinDepth;
  int32_t MaxDepth;
  int32_t MaxTickCounter;
  double Aggresivity;
  double HitterAgg;
  int32_t EntrySize;
  int32_t MinSizeInc;
  int32_t MinSizeDec;
  int32_t MaxSize;
  int32_t MaxNbOrder;
  int32_t Residu;
  double MovingAvg;
  double MovingVolume;
  double TradingImpact2Pos;
  double TradingImpactPosLimit;
  double TradingImpact;

  _MarketMakerMsg__isset __isset;

  void __set_Active(const bool val);

  void __set_MMLots(const int32_t val);

  void __set_MMValo(const double val);

  void __set_TotalMMBidQty(const int32_t val);

  void __set_MMBidQty(const int32_t val);

  void __set_MMAskQty(const int32_t val);

  void __set_TotalMMAskQty(const int32_t val);

  void __set_FairPrice(const double val);

  void __set_Position(const int32_t val);

  void __set_ConvergeRate(const double val);

  void __set_MovingAvgRatio(const double val);

  void __set_RiskReward(const double val);

  void __set_MinGain(const double val);

  void __set_MinDepth(const int32_t val);

  void __set_MaxDepth(const int32_t val);

  void __set_MaxTickCounter(const int32_t val);

  void __set_Aggresivity(const double val);

  void __set_HitterAgg(const double val);

  void __set_EntrySize(const int32_t val);

  void __set_MinSizeInc(const int32_t val);

  void __set_MinSizeDec(const int32_t val);

  void __set_MaxSize(const int32_t val);

  void __set_MaxNbOrder(const int32_t val);

  void __set_Residu(const int32_t val);

  void __set_MovingAvg(const double val);

  void __set_MovingVolume(const double val);

  void __set_TradingImpact2Pos(const double val);

  void __set_TradingImpactPosLimit(const double val);

  void __set_TradingImpact(const double val);

  bool operator == (const MarketMakerMsg & rhs) const
  {
    if (!(Active == rhs.Active))
      return false;
    if (!(MMLots == rhs.MMLots))
      return false;
    if (!(MMValo == rhs.MMValo))
      return false;
    if (!(TotalMMBidQty == rhs.TotalMMBidQty))
      return false;
    if (!(MMBidQty == rhs.MMBidQty))
      return false;
    if (!(MMAskQty == rhs.MMAskQty))
      return false;
    if (!(TotalMMAskQty == rhs.TotalMMAskQty))
      return false;
    if (!(FairPrice == rhs.FairPrice))
      return false;
    if (!(Position == rhs.Position))
      return false;
    if (!(ConvergeRate == rhs.ConvergeRate))
      return false;
    if (!(MovingAvgRatio == rhs.MovingAvgRatio))
      return false;
    if (!(RiskReward == rhs.RiskReward))
      return false;
    if (!(MinGain == rhs.MinGain))
      return false;
    if (!(MinDepth == rhs.MinDepth))
      return false;
    if (!(MaxDepth == rhs.MaxDepth))
      return false;
    if (!(MaxTickCounter == rhs.MaxTickCounter))
      return false;
    if (!(Aggresivity == rhs.Aggresivity))
      return false;
    if (!(HitterAgg == rhs.HitterAgg))
      return false;
    if (!(EntrySize == rhs.EntrySize))
      return false;
    if (!(MinSizeInc == rhs.MinSizeInc))
      return false;
    if (!(MinSizeDec == rhs.MinSizeDec))
      return false;
    if (!(MaxSize == rhs.MaxSize))
      return false;
    if (!(MaxNbOrder == rhs.MaxNbOrder))
      return false;
    if (!(Residu == rhs.Residu))
      return false;
    if (!(MovingAvg == rhs.MovingAvg))
      return false;
    if (!(MovingVolume == rhs.MovingVolume))
      return false;
    if (!(TradingImpact2Pos == rhs.TradingImpact2Pos))
      return false;
    if (!(TradingImpactPosLimit == rhs.TradingImpactPosLimit))
      return false;
    if (!(TradingImpact == rhs.TradingImpact))
      return false;
    return true;
  }
  bool operator != (const MarketMakerMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MarketMakerMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MarketMakerMsg &a, MarketMakerMsg &b);

inline std::ostream& operator<<(std::ostream& out, const MarketMakerMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _IAFutureMsg__isset {
  _IAFutureMsg__isset() : AtsInstrument(false), AtsName(false), isTrdFuture(false), isFuture1(false), isFuture2(false), Maturity(false), MarketMaker(false) {}
  bool AtsInstrument :1;
  bool AtsName :1;
  bool isTrdFuture :1;
  bool isFuture1 :1;
  bool isFuture2 :1;
  bool Maturity :1;
  bool MarketMaker :1;
} _IAFutureMsg__isset;

class IAFutureMsg {
 public:

  IAFutureMsg(const IAFutureMsg&);
  IAFutureMsg& operator=(const IAFutureMsg&);
  IAFutureMsg() : AtsName(), isTrdFuture(0), isFuture1(0), isFuture2(0), Maturity() {
  }

  virtual ~IAFutureMsg() throw();
   ::AtsGeneral::AtsInstrumentMsg AtsInstrument;
  std::string AtsName;
  bool isTrdFuture;
  bool isFuture1;
  bool isFuture2;
  std::string Maturity;
  MarketMakerMsg MarketMaker;

  _IAFutureMsg__isset __isset;

  void __set_AtsInstrument(const  ::AtsGeneral::AtsInstrumentMsg& val);

  void __set_AtsName(const std::string& val);

  void __set_isTrdFuture(const bool val);

  void __set_isFuture1(const bool val);

  void __set_isFuture2(const bool val);

  void __set_Maturity(const std::string& val);

  void __set_MarketMaker(const MarketMakerMsg& val);

  bool operator == (const IAFutureMsg & rhs) const
  {
    if (!(AtsInstrument == rhs.AtsInstrument))
      return false;
    if (!(AtsName == rhs.AtsName))
      return false;
    if (!(isTrdFuture == rhs.isTrdFuture))
      return false;
    if (!(isFuture1 == rhs.isFuture1))
      return false;
    if (!(isFuture2 == rhs.isFuture2))
      return false;
    if (!(Maturity == rhs.Maturity))
      return false;
    if (!(MarketMaker == rhs.MarketMaker))
      return false;
    return true;
  }
  bool operator != (const IAFutureMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IAFutureMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IAFutureMsg &a, IAFutureMsg &b);

inline std::ostream& operator<<(std::ostream& out, const IAFutureMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AtsFutureSpreadMsg__isset {
  _AtsFutureSpreadMsg__isset() : Ats(false), FairSpread(false), PosShift(false), AdjustSpread(false), Ratio(false), MinGainHit(false), MinGainCon(false), MinGainConExit(false), MinInterval(false), HitSize(false), ConSize(false), ConMinDiff(false), ConMaxDistance(false), HitStatus(false), ConStatus(false), ConBuy(false), ConSell(false), MaxWaitInterval(false), SpreadPos(false), Future1Pos(false), Future2Pos(false), BidHit(false), AskHit(false), BidCon(false), AskCon(false), Fut1Code(false), Fut2Code(false), MaxNumOrders(false), MaxPos(false), UseMarketOrder(false), PosConvex(false), ConvergeRate(false), LastKLineTime(false), KInterval(false), IgnoreUpDnLimit(false), Speed(false), SpeedConvergeRate(false), LastSpread(false), Volatility(false), MaxVolRange(false), RiskDegree(false), Fut2Cancel(false), FastConvergeRate(false) {}
  bool Ats :1;
  bool FairSpread :1;
  bool PosShift :1;
  bool AdjustSpread :1;
  bool Ratio :1;
  bool MinGainHit :1;
  bool MinGainCon :1;
  bool MinGainConExit :1;
  bool MinInterval :1;
  bool HitSize :1;
  bool ConSize :1;
  bool ConMinDiff :1;
  bool ConMaxDistance :1;
  bool HitStatus :1;
  bool ConStatus :1;
  bool ConBuy :1;
  bool ConSell :1;
  bool MaxWaitInterval :1;
  bool SpreadPos :1;
  bool Future1Pos :1;
  bool Future2Pos :1;
  bool BidHit :1;
  bool AskHit :1;
  bool BidCon :1;
  bool AskCon :1;
  bool Fut1Code :1;
  bool Fut2Code :1;
  bool MaxNumOrders :1;
  bool MaxPos :1;
  bool UseMarketOrder :1;
  bool PosConvex :1;
  bool ConvergeRate :1;
  bool LastKLineTime :1;
  bool KInterval :1;
  bool IgnoreUpDnLimit :1;
  bool Speed :1;
  bool SpeedConvergeRate :1;
  bool LastSpread :1;
  bool Volatility :1;
  bool MaxVolRange :1;
  bool RiskDegree :1;
  bool Fut2Cancel :1;
  bool FastConvergeRate :1;
} _AtsFutureSpreadMsg__isset;

class AtsFutureSpreadMsg {
 public:

  AtsFutureSpreadMsg(const AtsFutureSpreadMsg&);
  AtsFutureSpreadMsg& operator=(const AtsFutureSpreadMsg&);
  AtsFutureSpreadMsg() : Ats(), FairSpread(0), PosShift(0), AdjustSpread(0), Ratio(0), MinGainHit(0), MinGainCon(0), MinGainConExit(0), MinInterval(0), HitSize(0), ConSize(0), ConMinDiff(0), ConMaxDistance(0), HitStatus(0), ConStatus(0), ConBuy(0), ConSell(0), MaxWaitInterval(0), SpreadPos(0), Future1Pos(0), Future2Pos(0), BidHit(0), AskHit(0), BidCon(0), AskCon(0), Fut1Code(), Fut2Code(), MaxNumOrders(0), MaxPos(0), UseMarketOrder(0), PosConvex(0), ConvergeRate(0), LastKLineTime(), KInterval(), IgnoreUpDnLimit(0), Speed(0), SpeedConvergeRate(0), LastSpread(0), Volatility(0), MaxVolRange(0), RiskDegree(0), Fut2Cancel(0), FastConvergeRate(0) {
  }

  virtual ~AtsFutureSpreadMsg() throw();
  std::string Ats;
  double FairSpread;
  double PosShift;
  double AdjustSpread;
  double Ratio;
  double MinGainHit;
  double MinGainCon;
  double MinGainConExit;
  int32_t MinInterval;
  int32_t HitSize;
  int32_t ConSize;
  double ConMinDiff;
  double ConMaxDistance;
  bool HitStatus;
  bool ConStatus;
  bool ConBuy;
  bool ConSell;
  int32_t MaxWaitInterval;
  int32_t SpreadPos;
  int32_t Future1Pos;
  int32_t Future2Pos;
  double BidHit;
  double AskHit;
  double BidCon;
  double AskCon;
  std::string Fut1Code;
  std::string Fut2Code;
  int32_t MaxNumOrders;
  int32_t MaxPos;
  bool UseMarketOrder;
  double PosConvex;
  double ConvergeRate;
  std::string LastKLineTime;
  std::string KInterval;
  bool IgnoreUpDnLimit;
  double Speed;
  double SpeedConvergeRate;
  double LastSpread;
  double Volatility;
  double MaxVolRange;
  double RiskDegree;
  int32_t Fut2Cancel;
  double FastConvergeRate;

  _AtsFutureSpreadMsg__isset __isset;

  void __set_Ats(const std::string& val);

  void __set_FairSpread(const double val);

  void __set_PosShift(const double val);

  void __set_AdjustSpread(const double val);

  void __set_Ratio(const double val);

  void __set_MinGainHit(const double val);

  void __set_MinGainCon(const double val);

  void __set_MinGainConExit(const double val);

  void __set_MinInterval(const int32_t val);

  void __set_HitSize(const int32_t val);

  void __set_ConSize(const int32_t val);

  void __set_ConMinDiff(const double val);

  void __set_ConMaxDistance(const double val);

  void __set_HitStatus(const bool val);

  void __set_ConStatus(const bool val);

  void __set_ConBuy(const bool val);

  void __set_ConSell(const bool val);

  void __set_MaxWaitInterval(const int32_t val);

  void __set_SpreadPos(const int32_t val);

  void __set_Future1Pos(const int32_t val);

  void __set_Future2Pos(const int32_t val);

  void __set_BidHit(const double val);

  void __set_AskHit(const double val);

  void __set_BidCon(const double val);

  void __set_AskCon(const double val);

  void __set_Fut1Code(const std::string& val);

  void __set_Fut2Code(const std::string& val);

  void __set_MaxNumOrders(const int32_t val);

  void __set_MaxPos(const int32_t val);

  void __set_UseMarketOrder(const bool val);

  void __set_PosConvex(const double val);

  void __set_ConvergeRate(const double val);

  void __set_LastKLineTime(const std::string& val);

  void __set_KInterval(const std::string& val);

  void __set_IgnoreUpDnLimit(const bool val);

  void __set_Speed(const double val);

  void __set_SpeedConvergeRate(const double val);

  void __set_LastSpread(const double val);

  void __set_Volatility(const double val);

  void __set_MaxVolRange(const double val);

  void __set_RiskDegree(const double val);

  void __set_Fut2Cancel(const int32_t val);

  void __set_FastConvergeRate(const double val);

  bool operator == (const AtsFutureSpreadMsg & rhs) const
  {
    if (!(Ats == rhs.Ats))
      return false;
    if (!(FairSpread == rhs.FairSpread))
      return false;
    if (!(PosShift == rhs.PosShift))
      return false;
    if (!(AdjustSpread == rhs.AdjustSpread))
      return false;
    if (!(Ratio == rhs.Ratio))
      return false;
    if (!(MinGainHit == rhs.MinGainHit))
      return false;
    if (!(MinGainCon == rhs.MinGainCon))
      return false;
    if (!(MinGainConExit == rhs.MinGainConExit))
      return false;
    if (!(MinInterval == rhs.MinInterval))
      return false;
    if (!(HitSize == rhs.HitSize))
      return false;
    if (!(ConSize == rhs.ConSize))
      return false;
    if (!(ConMinDiff == rhs.ConMinDiff))
      return false;
    if (!(ConMaxDistance == rhs.ConMaxDistance))
      return false;
    if (!(HitStatus == rhs.HitStatus))
      return false;
    if (!(ConStatus == rhs.ConStatus))
      return false;
    if (!(ConBuy == rhs.ConBuy))
      return false;
    if (!(ConSell == rhs.ConSell))
      return false;
    if (!(MaxWaitInterval == rhs.MaxWaitInterval))
      return false;
    if (!(SpreadPos == rhs.SpreadPos))
      return false;
    if (!(Future1Pos == rhs.Future1Pos))
      return false;
    if (!(Future2Pos == rhs.Future2Pos))
      return false;
    if (!(BidHit == rhs.BidHit))
      return false;
    if (!(AskHit == rhs.AskHit))
      return false;
    if (!(BidCon == rhs.BidCon))
      return false;
    if (!(AskCon == rhs.AskCon))
      return false;
    if (!(Fut1Code == rhs.Fut1Code))
      return false;
    if (!(Fut2Code == rhs.Fut2Code))
      return false;
    if (!(MaxNumOrders == rhs.MaxNumOrders))
      return false;
    if (!(MaxPos == rhs.MaxPos))
      return false;
    if (!(UseMarketOrder == rhs.UseMarketOrder))
      return false;
    if (!(PosConvex == rhs.PosConvex))
      return false;
    if (!(ConvergeRate == rhs.ConvergeRate))
      return false;
    if (!(LastKLineTime == rhs.LastKLineTime))
      return false;
    if (!(KInterval == rhs.KInterval))
      return false;
    if (!(IgnoreUpDnLimit == rhs.IgnoreUpDnLimit))
      return false;
    if (!(Speed == rhs.Speed))
      return false;
    if (!(SpeedConvergeRate == rhs.SpeedConvergeRate))
      return false;
    if (!(LastSpread == rhs.LastSpread))
      return false;
    if (!(Volatility == rhs.Volatility))
      return false;
    if (!(MaxVolRange == rhs.MaxVolRange))
      return false;
    if (!(RiskDegree == rhs.RiskDegree))
      return false;
    if (!(Fut2Cancel == rhs.Fut2Cancel))
      return false;
    if (!(FastConvergeRate == rhs.FastConvergeRate))
      return false;
    return true;
  }
  bool operator != (const AtsFutureSpreadMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AtsFutureSpreadMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AtsFutureSpreadMsg &a, AtsFutureSpreadMsg &b);

inline std::ostream& operator<<(std::ostream& out, const AtsFutureSpreadMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _KlineConfigMsg__isset {
  _KlineConfigMsg__isset() : KlineNum(false), KlineDur(false) {}
  bool KlineNum :1;
  bool KlineDur :1;
} _KlineConfigMsg__isset;

class KlineConfigMsg {
 public:

  KlineConfigMsg(const KlineConfigMsg&);
  KlineConfigMsg& operator=(const KlineConfigMsg&);
  KlineConfigMsg() : KlineNum(0), KlineDur(0) {
  }

  virtual ~KlineConfigMsg() throw();
  int32_t KlineNum;
  int32_t KlineDur;

  _KlineConfigMsg__isset __isset;

  void __set_KlineNum(const int32_t val);

  void __set_KlineDur(const int32_t val);

  bool operator == (const KlineConfigMsg & rhs) const
  {
    if (!(KlineNum == rhs.KlineNum))
      return false;
    if (!(KlineDur == rhs.KlineDur))
      return false;
    return true;
  }
  bool operator != (const KlineConfigMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KlineConfigMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(KlineConfigMsg &a, KlineConfigMsg &b);

inline std::ostream& operator<<(std::ostream& out, const KlineConfigMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TWAPDataMsg__isset {
  _TWAPDataMsg__isset() : Time(false), Alpha(false), Max_Order_Size(false), Min_Order_Size(false), Sleep_Time(false) {}
  bool Time :1;
  bool Alpha :1;
  bool Max_Order_Size :1;
  bool Min_Order_Size :1;
  bool Sleep_Time :1;
} _TWAPDataMsg__isset;

class TWAPDataMsg {
 public:

  TWAPDataMsg(const TWAPDataMsg&);
  TWAPDataMsg& operator=(const TWAPDataMsg&);
  TWAPDataMsg() : Time(0), Alpha(0), Max_Order_Size(0), Min_Order_Size(0), Sleep_Time(0) {
  }

  virtual ~TWAPDataMsg() throw();
  int32_t Time;
  double Alpha;
  int32_t Max_Order_Size;
  int32_t Min_Order_Size;
  int32_t Sleep_Time;

  _TWAPDataMsg__isset __isset;

  void __set_Time(const int32_t val);

  void __set_Alpha(const double val);

  void __set_Max_Order_Size(const int32_t val);

  void __set_Min_Order_Size(const int32_t val);

  void __set_Sleep_Time(const int32_t val);

  bool operator == (const TWAPDataMsg & rhs) const
  {
    if (!(Time == rhs.Time))
      return false;
    if (!(Alpha == rhs.Alpha))
      return false;
    if (!(Max_Order_Size == rhs.Max_Order_Size))
      return false;
    if (!(Min_Order_Size == rhs.Min_Order_Size))
      return false;
    if (!(Sleep_Time == rhs.Sleep_Time))
      return false;
    return true;
  }
  bool operator != (const TWAPDataMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TWAPDataMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TWAPDataMsg &a, TWAPDataMsg &b);

inline std::ostream& operator<<(std::ostream& out, const TWAPDataMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _KlineDataMsg__isset {
  _KlineDataMsg__isset() : Time(false), Open(false), High(false), Low(false), Close(false), TR(false), Signal(false) {}
  bool Time :1;
  bool Open :1;
  bool High :1;
  bool Low :1;
  bool Close :1;
  bool TR :1;
  bool Signal :1;
} _KlineDataMsg__isset;

class KlineDataMsg {
 public:

  KlineDataMsg(const KlineDataMsg&);
  KlineDataMsg& operator=(const KlineDataMsg&);
  KlineDataMsg() : Time(), Open(0), High(0), Low(0), Close(0), TR(0), Signal(0) {
  }

  virtual ~KlineDataMsg() throw();
  std::string Time;
  double Open;
  double High;
  double Low;
  double Close;
  double TR;
  int32_t Signal;

  _KlineDataMsg__isset __isset;

  void __set_Time(const std::string& val);

  void __set_Open(const double val);

  void __set_High(const double val);

  void __set_Low(const double val);

  void __set_Close(const double val);

  void __set_TR(const double val);

  void __set_Signal(const int32_t val);

  bool operator == (const KlineDataMsg & rhs) const
  {
    if (!(Time == rhs.Time))
      return false;
    if (!(Open == rhs.Open))
      return false;
    if (!(High == rhs.High))
      return false;
    if (!(Low == rhs.Low))
      return false;
    if (!(Close == rhs.Close))
      return false;
    if (!(TR == rhs.TR))
      return false;
    if (!(Signal == rhs.Signal))
      return false;
    return true;
  }
  bool operator != (const KlineDataMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KlineDataMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(KlineDataMsg &a, KlineDataMsg &b);

inline std::ostream& operator<<(std::ostream& out, const KlineDataMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TurtleAlgoMsg__isset {
  _TurtleAlgoMsg__isset() : LastKLineTime(false), KInterval(false), PriceDatas(false), CurrentPrice(false), NumOpenKline(false), NumCloseKline(false), MA_Fast(false), MA_Slow(false), Lambda_Fast(false), Lambda_Slow(false), Signal(false), ATR(false), PosRatio(false), LastUpdatePrice(false), MaxPosLimit(false), UpdateKline(false), EnableTurtle(false), Instr_Code(false) {}
  bool LastKLineTime :1;
  bool KInterval :1;
  bool PriceDatas :1;
  bool CurrentPrice :1;
  bool NumOpenKline :1;
  bool NumCloseKline :1;
  bool MA_Fast :1;
  bool MA_Slow :1;
  bool Lambda_Fast :1;
  bool Lambda_Slow :1;
  bool Signal :1;
  bool ATR :1;
  bool PosRatio :1;
  bool LastUpdatePrice :1;
  bool MaxPosLimit :1;
  bool UpdateKline :1;
  bool EnableTurtle :1;
  bool Instr_Code :1;
} _TurtleAlgoMsg__isset;

class TurtleAlgoMsg {
 public:

  TurtleAlgoMsg(const TurtleAlgoMsg&);
  TurtleAlgoMsg& operator=(const TurtleAlgoMsg&);
  TurtleAlgoMsg() : LastKLineTime(), KInterval(), NumOpenKline(0), NumCloseKline(0), MA_Fast(0), MA_Slow(0), Lambda_Fast(0), Lambda_Slow(0), Signal(0), ATR(0), PosRatio(0), LastUpdatePrice(0), MaxPosLimit(0), UpdateKline(0), EnableTurtle(0), Instr_Code() {
  }

  virtual ~TurtleAlgoMsg() throw();
  std::string LastKLineTime;
  std::string KInterval;
  std::vector<KlineDataMsg>  PriceDatas;
  KlineDataMsg CurrentPrice;
  int32_t NumOpenKline;
  int32_t NumCloseKline;
  double MA_Fast;
  double MA_Slow;
  double Lambda_Fast;
  double Lambda_Slow;
  int32_t Signal;
  double ATR;
  double PosRatio;
  double LastUpdatePrice;
  int32_t MaxPosLimit;
  bool UpdateKline;
  bool EnableTurtle;
  std::string Instr_Code;

  _TurtleAlgoMsg__isset __isset;

  void __set_LastKLineTime(const std::string& val);

  void __set_KInterval(const std::string& val);

  void __set_PriceDatas(const std::vector<KlineDataMsg> & val);

  void __set_CurrentPrice(const KlineDataMsg& val);

  void __set_NumOpenKline(const int32_t val);

  void __set_NumCloseKline(const int32_t val);

  void __set_MA_Fast(const double val);

  void __set_MA_Slow(const double val);

  void __set_Lambda_Fast(const double val);

  void __set_Lambda_Slow(const double val);

  void __set_Signal(const int32_t val);

  void __set_ATR(const double val);

  void __set_PosRatio(const double val);

  void __set_LastUpdatePrice(const double val);

  void __set_MaxPosLimit(const int32_t val);

  void __set_UpdateKline(const bool val);

  void __set_EnableTurtle(const bool val);

  void __set_Instr_Code(const std::string& val);

  bool operator == (const TurtleAlgoMsg & rhs) const
  {
    if (!(LastKLineTime == rhs.LastKLineTime))
      return false;
    if (!(KInterval == rhs.KInterval))
      return false;
    if (!(PriceDatas == rhs.PriceDatas))
      return false;
    if (!(CurrentPrice == rhs.CurrentPrice))
      return false;
    if (!(NumOpenKline == rhs.NumOpenKline))
      return false;
    if (!(NumCloseKline == rhs.NumCloseKline))
      return false;
    if (!(MA_Fast == rhs.MA_Fast))
      return false;
    if (!(MA_Slow == rhs.MA_Slow))
      return false;
    if (!(Lambda_Fast == rhs.Lambda_Fast))
      return false;
    if (!(Lambda_Slow == rhs.Lambda_Slow))
      return false;
    if (!(Signal == rhs.Signal))
      return false;
    if (!(ATR == rhs.ATR))
      return false;
    if (!(PosRatio == rhs.PosRatio))
      return false;
    if (!(LastUpdatePrice == rhs.LastUpdatePrice))
      return false;
    if (!(MaxPosLimit == rhs.MaxPosLimit))
      return false;
    if (!(UpdateKline == rhs.UpdateKline))
      return false;
    if (!(EnableTurtle == rhs.EnableTurtle))
      return false;
    if (!(Instr_Code == rhs.Instr_Code))
      return false;
    return true;
  }
  bool operator != (const TurtleAlgoMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TurtleAlgoMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TurtleAlgoMsg &a, TurtleAlgoMsg &b);

inline std::ostream& operator<<(std::ostream& out, const TurtleAlgoMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CTAAtsMsg__isset {
  _CTAAtsMsg__isset() : Ats(false), AllFutures(false), KeepOrders(false), ForceOpen(false), AtsSpread(false), AtsIntraDataCols(false), FeedsourcesStr(false), ConnectionsStr(false), Underlyings(false), DoFutureMarketMaker(false), MarketMakerCanReduce(false), Turtle(false) {}
  bool Ats :1;
  bool AllFutures :1;
  bool KeepOrders :1;
  bool ForceOpen :1;
  bool AtsSpread :1;
  bool AtsIntraDataCols :1;
  bool FeedsourcesStr :1;
  bool ConnectionsStr :1;
  bool Underlyings :1;
  bool DoFutureMarketMaker :1;
  bool MarketMakerCanReduce :1;
  bool Turtle :1;
} _CTAAtsMsg__isset;

class CTAAtsMsg {
 public:

  CTAAtsMsg(const CTAAtsMsg&);
  CTAAtsMsg& operator=(const CTAAtsMsg&);
  CTAAtsMsg() : KeepOrders(0), ForceOpen(0), FeedsourcesStr(), ConnectionsStr(), DoFutureMarketMaker(0), MarketMakerCanReduce(0) {
  }

  virtual ~CTAAtsMsg() throw();
   ::AtsGeneral::AtsMsg Ats;
  std::vector<IAFutureMsg>  AllFutures;
  bool KeepOrders;
  bool ForceOpen;
  AtsFutureSpreadMsg AtsSpread;
  std::vector<std::string>  AtsIntraDataCols;
  std::string FeedsourcesStr;
  std::string ConnectionsStr;
  std::vector< ::AtsGeneral::UnderlyingMsg>  Underlyings;
  bool DoFutureMarketMaker;
  bool MarketMakerCanReduce;
  TurtleAlgoMsg Turtle;

  _CTAAtsMsg__isset __isset;

  void __set_Ats(const  ::AtsGeneral::AtsMsg& val);

  void __set_AllFutures(const std::vector<IAFutureMsg> & val);

  void __set_KeepOrders(const bool val);

  void __set_ForceOpen(const bool val);

  void __set_AtsSpread(const AtsFutureSpreadMsg& val);

  void __set_AtsIntraDataCols(const std::vector<std::string> & val);

  void __set_FeedsourcesStr(const std::string& val);

  void __set_ConnectionsStr(const std::string& val);

  void __set_Underlyings(const std::vector< ::AtsGeneral::UnderlyingMsg> & val);

  void __set_DoFutureMarketMaker(const bool val);

  void __set_MarketMakerCanReduce(const bool val);

  void __set_Turtle(const TurtleAlgoMsg& val);

  bool operator == (const CTAAtsMsg & rhs) const
  {
    if (!(Ats == rhs.Ats))
      return false;
    if (!(AllFutures == rhs.AllFutures))
      return false;
    if (!(KeepOrders == rhs.KeepOrders))
      return false;
    if (!(ForceOpen == rhs.ForceOpen))
      return false;
    if (!(AtsSpread == rhs.AtsSpread))
      return false;
    if (!(AtsIntraDataCols == rhs.AtsIntraDataCols))
      return false;
    if (!(FeedsourcesStr == rhs.FeedsourcesStr))
      return false;
    if (!(ConnectionsStr == rhs.ConnectionsStr))
      return false;
    if (!(Underlyings == rhs.Underlyings))
      return false;
    if (!(DoFutureMarketMaker == rhs.DoFutureMarketMaker))
      return false;
    if (!(MarketMakerCanReduce == rhs.MarketMakerCanReduce))
      return false;
    if (!(Turtle == rhs.Turtle))
      return false;
    return true;
  }
  bool operator != (const CTAAtsMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CTAAtsMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CTAAtsMsg &a, CTAAtsMsg &b);

inline std::ostream& operator<<(std::ostream& out, const CTAAtsMsg& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
