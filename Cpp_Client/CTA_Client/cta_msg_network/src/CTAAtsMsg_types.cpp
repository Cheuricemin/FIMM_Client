/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "CTAAtsMsg_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace CTAMsg {

int _kTradingTypeValues[] = {
  TradingType::Unknown,
  TradingType::Manual,
  TradingType::Hitter,
  TradingType::Contrib,
  TradingType::Spread,
  TradingType::ContribHedge,
  TradingType::Max
};
const char* _kTradingTypeNames[] = {
  "Unknown",
  "Manual",
  "Hitter",
  "Contrib",
  "Spread",
  "ContribHedge",
  "Max"
};
const std::map<int, const char*> _TradingType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTradingTypeValues, _kTradingTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


MarketMakerMsg::~MarketMakerMsg() throw() {
}


void MarketMakerMsg::__set_Active(const bool val) {
  this->Active = val;
}

void MarketMakerMsg::__set_MMLots(const int32_t val) {
  this->MMLots = val;
}

void MarketMakerMsg::__set_MMValo(const double val) {
  this->MMValo = val;
}

void MarketMakerMsg::__set_TotalMMBidQty(const int32_t val) {
  this->TotalMMBidQty = val;
}

void MarketMakerMsg::__set_MMBidQty(const int32_t val) {
  this->MMBidQty = val;
}

void MarketMakerMsg::__set_MMAskQty(const int32_t val) {
  this->MMAskQty = val;
}

void MarketMakerMsg::__set_TotalMMAskQty(const int32_t val) {
  this->TotalMMAskQty = val;
}

void MarketMakerMsg::__set_FairPrice(const double val) {
  this->FairPrice = val;
}

void MarketMakerMsg::__set_Position(const int32_t val) {
  this->Position = val;
}

void MarketMakerMsg::__set_ConvergeRate(const double val) {
  this->ConvergeRate = val;
}

void MarketMakerMsg::__set_MovingAvgRatio(const double val) {
  this->MovingAvgRatio = val;
}

void MarketMakerMsg::__set_RiskReward(const double val) {
  this->RiskReward = val;
}

void MarketMakerMsg::__set_MinGain(const double val) {
  this->MinGain = val;
}

void MarketMakerMsg::__set_MinDepth(const int32_t val) {
  this->MinDepth = val;
}

void MarketMakerMsg::__set_MaxDepth(const int32_t val) {
  this->MaxDepth = val;
}

void MarketMakerMsg::__set_MaxTickCounter(const int32_t val) {
  this->MaxTickCounter = val;
}

void MarketMakerMsg::__set_Aggresivity(const double val) {
  this->Aggresivity = val;
}

void MarketMakerMsg::__set_HitterAgg(const double val) {
  this->HitterAgg = val;
}

void MarketMakerMsg::__set_EntrySize(const int32_t val) {
  this->EntrySize = val;
}

void MarketMakerMsg::__set_MinSizeInc(const int32_t val) {
  this->MinSizeInc = val;
}

void MarketMakerMsg::__set_MinSizeDec(const int32_t val) {
  this->MinSizeDec = val;
}

void MarketMakerMsg::__set_MaxSize(const int32_t val) {
  this->MaxSize = val;
}

void MarketMakerMsg::__set_MaxNbOrder(const int32_t val) {
  this->MaxNbOrder = val;
}

void MarketMakerMsg::__set_Residu(const int32_t val) {
  this->Residu = val;
}

void MarketMakerMsg::__set_MovingAvg(const double val) {
  this->MovingAvg = val;
}

void MarketMakerMsg::__set_MovingVolume(const double val) {
  this->MovingVolume = val;
}

void MarketMakerMsg::__set_TradingImpact2Pos(const double val) {
  this->TradingImpact2Pos = val;
}

void MarketMakerMsg::__set_TradingImpactPosLimit(const double val) {
  this->TradingImpactPosLimit = val;
}

void MarketMakerMsg::__set_TradingImpact(const double val) {
  this->TradingImpact = val;
}

uint32_t MarketMakerMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->Active);
          this->__isset.Active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MMLots);
          this->__isset.MMLots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MMValo);
          this->__isset.MMValo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->TotalMMBidQty);
          this->__isset.TotalMMBidQty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MMBidQty);
          this->__isset.MMBidQty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MMAskQty);
          this->__isset.MMAskQty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->TotalMMAskQty);
          this->__isset.TotalMMAskQty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->FairPrice);
          this->__isset.FairPrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Position);
          this->__isset.Position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ConvergeRate);
          this->__isset.ConvergeRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MovingAvgRatio);
          this->__isset.MovingAvgRatio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->RiskReward);
          this->__isset.RiskReward = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MinGain);
          this->__isset.MinGain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MinDepth);
          this->__isset.MinDepth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MaxDepth);
          this->__isset.MaxDepth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MaxTickCounter);
          this->__isset.MaxTickCounter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Aggresivity);
          this->__isset.Aggresivity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->HitterAgg);
          this->__isset.HitterAgg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->EntrySize);
          this->__isset.EntrySize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MinSizeInc);
          this->__isset.MinSizeInc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MinSizeDec);
          this->__isset.MinSizeDec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MaxSize);
          this->__isset.MaxSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MaxNbOrder);
          this->__isset.MaxNbOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Residu);
          this->__isset.Residu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MovingAvg);
          this->__isset.MovingAvg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MovingVolume);
          this->__isset.MovingVolume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TradingImpact2Pos);
          this->__isset.TradingImpact2Pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TradingImpactPosLimit);
          this->__isset.TradingImpactPosLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TradingImpact);
          this->__isset.TradingImpact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MarketMakerMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MarketMakerMsg");

  xfer += oprot->writeFieldBegin("Active", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->Active);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MMLots", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->MMLots);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MMValo", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->MMValo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TotalMMBidQty", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->TotalMMBidQty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MMBidQty", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->MMBidQty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MMAskQty", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->MMAskQty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TotalMMAskQty", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->TotalMMAskQty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("FairPrice", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->FairPrice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Position", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->Position);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConvergeRate", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->ConvergeRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MovingAvgRatio", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->MovingAvgRatio);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("RiskReward", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->RiskReward);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinGain", ::apache::thrift::protocol::T_DOUBLE, 13);
  xfer += oprot->writeDouble(this->MinGain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinDepth", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->MinDepth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxDepth", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->MaxDepth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxTickCounter", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32(this->MaxTickCounter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Aggresivity", ::apache::thrift::protocol::T_DOUBLE, 17);
  xfer += oprot->writeDouble(this->Aggresivity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("HitterAgg", ::apache::thrift::protocol::T_DOUBLE, 18);
  xfer += oprot->writeDouble(this->HitterAgg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("EntrySize", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->EntrySize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinSizeInc", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->MinSizeInc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinSizeDec", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->MinSizeDec);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxSize", ::apache::thrift::protocol::T_I32, 22);
  xfer += oprot->writeI32(this->MaxSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxNbOrder", ::apache::thrift::protocol::T_I32, 23);
  xfer += oprot->writeI32(this->MaxNbOrder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Residu", ::apache::thrift::protocol::T_I32, 24);
  xfer += oprot->writeI32(this->Residu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MovingAvg", ::apache::thrift::protocol::T_DOUBLE, 25);
  xfer += oprot->writeDouble(this->MovingAvg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MovingVolume", ::apache::thrift::protocol::T_DOUBLE, 26);
  xfer += oprot->writeDouble(this->MovingVolume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TradingImpact2Pos", ::apache::thrift::protocol::T_DOUBLE, 27);
  xfer += oprot->writeDouble(this->TradingImpact2Pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TradingImpactPosLimit", ::apache::thrift::protocol::T_DOUBLE, 28);
  xfer += oprot->writeDouble(this->TradingImpactPosLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TradingImpact", ::apache::thrift::protocol::T_DOUBLE, 29);
  xfer += oprot->writeDouble(this->TradingImpact);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MarketMakerMsg &a, MarketMakerMsg &b) {
  using ::std::swap;
  swap(a.Active, b.Active);
  swap(a.MMLots, b.MMLots);
  swap(a.MMValo, b.MMValo);
  swap(a.TotalMMBidQty, b.TotalMMBidQty);
  swap(a.MMBidQty, b.MMBidQty);
  swap(a.MMAskQty, b.MMAskQty);
  swap(a.TotalMMAskQty, b.TotalMMAskQty);
  swap(a.FairPrice, b.FairPrice);
  swap(a.Position, b.Position);
  swap(a.ConvergeRate, b.ConvergeRate);
  swap(a.MovingAvgRatio, b.MovingAvgRatio);
  swap(a.RiskReward, b.RiskReward);
  swap(a.MinGain, b.MinGain);
  swap(a.MinDepth, b.MinDepth);
  swap(a.MaxDepth, b.MaxDepth);
  swap(a.MaxTickCounter, b.MaxTickCounter);
  swap(a.Aggresivity, b.Aggresivity);
  swap(a.HitterAgg, b.HitterAgg);
  swap(a.EntrySize, b.EntrySize);
  swap(a.MinSizeInc, b.MinSizeInc);
  swap(a.MinSizeDec, b.MinSizeDec);
  swap(a.MaxSize, b.MaxSize);
  swap(a.MaxNbOrder, b.MaxNbOrder);
  swap(a.Residu, b.Residu);
  swap(a.MovingAvg, b.MovingAvg);
  swap(a.MovingVolume, b.MovingVolume);
  swap(a.TradingImpact2Pos, b.TradingImpact2Pos);
  swap(a.TradingImpactPosLimit, b.TradingImpactPosLimit);
  swap(a.TradingImpact, b.TradingImpact);
  swap(a.__isset, b.__isset);
}

MarketMakerMsg::MarketMakerMsg(const MarketMakerMsg& other0) {
  Active = other0.Active;
  MMLots = other0.MMLots;
  MMValo = other0.MMValo;
  TotalMMBidQty = other0.TotalMMBidQty;
  MMBidQty = other0.MMBidQty;
  MMAskQty = other0.MMAskQty;
  TotalMMAskQty = other0.TotalMMAskQty;
  FairPrice = other0.FairPrice;
  Position = other0.Position;
  ConvergeRate = other0.ConvergeRate;
  MovingAvgRatio = other0.MovingAvgRatio;
  RiskReward = other0.RiskReward;
  MinGain = other0.MinGain;
  MinDepth = other0.MinDepth;
  MaxDepth = other0.MaxDepth;
  MaxTickCounter = other0.MaxTickCounter;
  Aggresivity = other0.Aggresivity;
  HitterAgg = other0.HitterAgg;
  EntrySize = other0.EntrySize;
  MinSizeInc = other0.MinSizeInc;
  MinSizeDec = other0.MinSizeDec;
  MaxSize = other0.MaxSize;
  MaxNbOrder = other0.MaxNbOrder;
  Residu = other0.Residu;
  MovingAvg = other0.MovingAvg;
  MovingVolume = other0.MovingVolume;
  TradingImpact2Pos = other0.TradingImpact2Pos;
  TradingImpactPosLimit = other0.TradingImpactPosLimit;
  TradingImpact = other0.TradingImpact;
  __isset = other0.__isset;
}
MarketMakerMsg& MarketMakerMsg::operator=(const MarketMakerMsg& other1) {
  Active = other1.Active;
  MMLots = other1.MMLots;
  MMValo = other1.MMValo;
  TotalMMBidQty = other1.TotalMMBidQty;
  MMBidQty = other1.MMBidQty;
  MMAskQty = other1.MMAskQty;
  TotalMMAskQty = other1.TotalMMAskQty;
  FairPrice = other1.FairPrice;
  Position = other1.Position;
  ConvergeRate = other1.ConvergeRate;
  MovingAvgRatio = other1.MovingAvgRatio;
  RiskReward = other1.RiskReward;
  MinGain = other1.MinGain;
  MinDepth = other1.MinDepth;
  MaxDepth = other1.MaxDepth;
  MaxTickCounter = other1.MaxTickCounter;
  Aggresivity = other1.Aggresivity;
  HitterAgg = other1.HitterAgg;
  EntrySize = other1.EntrySize;
  MinSizeInc = other1.MinSizeInc;
  MinSizeDec = other1.MinSizeDec;
  MaxSize = other1.MaxSize;
  MaxNbOrder = other1.MaxNbOrder;
  Residu = other1.Residu;
  MovingAvg = other1.MovingAvg;
  MovingVolume = other1.MovingVolume;
  TradingImpact2Pos = other1.TradingImpact2Pos;
  TradingImpactPosLimit = other1.TradingImpactPosLimit;
  TradingImpact = other1.TradingImpact;
  __isset = other1.__isset;
  return *this;
}
void MarketMakerMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MarketMakerMsg(";
  out << "Active=" << to_string(Active);
  out << ", " << "MMLots=" << to_string(MMLots);
  out << ", " << "MMValo=" << to_string(MMValo);
  out << ", " << "TotalMMBidQty=" << to_string(TotalMMBidQty);
  out << ", " << "MMBidQty=" << to_string(MMBidQty);
  out << ", " << "MMAskQty=" << to_string(MMAskQty);
  out << ", " << "TotalMMAskQty=" << to_string(TotalMMAskQty);
  out << ", " << "FairPrice=" << to_string(FairPrice);
  out << ", " << "Position=" << to_string(Position);
  out << ", " << "ConvergeRate=" << to_string(ConvergeRate);
  out << ", " << "MovingAvgRatio=" << to_string(MovingAvgRatio);
  out << ", " << "RiskReward=" << to_string(RiskReward);
  out << ", " << "MinGain=" << to_string(MinGain);
  out << ", " << "MinDepth=" << to_string(MinDepth);
  out << ", " << "MaxDepth=" << to_string(MaxDepth);
  out << ", " << "MaxTickCounter=" << to_string(MaxTickCounter);
  out << ", " << "Aggresivity=" << to_string(Aggresivity);
  out << ", " << "HitterAgg=" << to_string(HitterAgg);
  out << ", " << "EntrySize=" << to_string(EntrySize);
  out << ", " << "MinSizeInc=" << to_string(MinSizeInc);
  out << ", " << "MinSizeDec=" << to_string(MinSizeDec);
  out << ", " << "MaxSize=" << to_string(MaxSize);
  out << ", " << "MaxNbOrder=" << to_string(MaxNbOrder);
  out << ", " << "Residu=" << to_string(Residu);
  out << ", " << "MovingAvg=" << to_string(MovingAvg);
  out << ", " << "MovingVolume=" << to_string(MovingVolume);
  out << ", " << "TradingImpact2Pos=" << to_string(TradingImpact2Pos);
  out << ", " << "TradingImpactPosLimit=" << to_string(TradingImpactPosLimit);
  out << ", " << "TradingImpact=" << to_string(TradingImpact);
  out << ")";
}


IAFutureMsg::~IAFutureMsg() throw() {
}


void IAFutureMsg::__set_AtsInstrument(const  ::AtsGeneral::AtsInstrumentMsg& val) {
  this->AtsInstrument = val;
}

void IAFutureMsg::__set_AtsName(const std::string& val) {
  this->AtsName = val;
}

void IAFutureMsg::__set_isTrdFuture(const bool val) {
  this->isTrdFuture = val;
}

void IAFutureMsg::__set_isFuture1(const bool val) {
  this->isFuture1 = val;
}

void IAFutureMsg::__set_isFuture2(const bool val) {
  this->isFuture2 = val;
}

void IAFutureMsg::__set_Maturity(const std::string& val) {
  this->Maturity = val;
}

void IAFutureMsg::__set_MarketMaker(const MarketMakerMsg& val) {
  this->MarketMaker = val;
}

uint32_t IAFutureMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->AtsInstrument.read(iprot);
          this->__isset.AtsInstrument = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->AtsName);
          this->__isset.AtsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isTrdFuture);
          this->__isset.isTrdFuture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isFuture1);
          this->__isset.isFuture1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isFuture2);
          this->__isset.isFuture2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Maturity);
          this->__isset.Maturity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->MarketMaker.read(iprot);
          this->__isset.MarketMaker = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IAFutureMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IAFutureMsg");

  xfer += oprot->writeFieldBegin("AtsInstrument", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->AtsInstrument.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AtsName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->AtsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isTrdFuture", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isTrdFuture);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isFuture1", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->isFuture1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isFuture2", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->isFuture2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Maturity", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->Maturity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MarketMaker", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->MarketMaker.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IAFutureMsg &a, IAFutureMsg &b) {
  using ::std::swap;
  swap(a.AtsInstrument, b.AtsInstrument);
  swap(a.AtsName, b.AtsName);
  swap(a.isTrdFuture, b.isTrdFuture);
  swap(a.isFuture1, b.isFuture1);
  swap(a.isFuture2, b.isFuture2);
  swap(a.Maturity, b.Maturity);
  swap(a.MarketMaker, b.MarketMaker);
  swap(a.__isset, b.__isset);
}

IAFutureMsg::IAFutureMsg(const IAFutureMsg& other2) {
  AtsInstrument = other2.AtsInstrument;
  AtsName = other2.AtsName;
  isTrdFuture = other2.isTrdFuture;
  isFuture1 = other2.isFuture1;
  isFuture2 = other2.isFuture2;
  Maturity = other2.Maturity;
  MarketMaker = other2.MarketMaker;
  __isset = other2.__isset;
}
IAFutureMsg& IAFutureMsg::operator=(const IAFutureMsg& other3) {
  AtsInstrument = other3.AtsInstrument;
  AtsName = other3.AtsName;
  isTrdFuture = other3.isTrdFuture;
  isFuture1 = other3.isFuture1;
  isFuture2 = other3.isFuture2;
  Maturity = other3.Maturity;
  MarketMaker = other3.MarketMaker;
  __isset = other3.__isset;
  return *this;
}
void IAFutureMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IAFutureMsg(";
  out << "AtsInstrument=" << to_string(AtsInstrument);
  out << ", " << "AtsName=" << to_string(AtsName);
  out << ", " << "isTrdFuture=" << to_string(isTrdFuture);
  out << ", " << "isFuture1=" << to_string(isFuture1);
  out << ", " << "isFuture2=" << to_string(isFuture2);
  out << ", " << "Maturity=" << to_string(Maturity);
  out << ", " << "MarketMaker=" << to_string(MarketMaker);
  out << ")";
}


AtsFutureSpreadMsg::~AtsFutureSpreadMsg() throw() {
}


void AtsFutureSpreadMsg::__set_Ats(const std::string& val) {
  this->Ats = val;
}

void AtsFutureSpreadMsg::__set_FairSpread(const double val) {
  this->FairSpread = val;
}

void AtsFutureSpreadMsg::__set_PosShift(const double val) {
  this->PosShift = val;
}

void AtsFutureSpreadMsg::__set_AdjustSpread(const double val) {
  this->AdjustSpread = val;
}

void AtsFutureSpreadMsg::__set_Ratio(const double val) {
  this->Ratio = val;
}

void AtsFutureSpreadMsg::__set_MinGainHit(const double val) {
  this->MinGainHit = val;
}

void AtsFutureSpreadMsg::__set_MinGainCon(const double val) {
  this->MinGainCon = val;
}

void AtsFutureSpreadMsg::__set_MinGainConExit(const double val) {
  this->MinGainConExit = val;
}

void AtsFutureSpreadMsg::__set_MinInterval(const int32_t val) {
  this->MinInterval = val;
}

void AtsFutureSpreadMsg::__set_HitSize(const int32_t val) {
  this->HitSize = val;
}

void AtsFutureSpreadMsg::__set_ConSize(const int32_t val) {
  this->ConSize = val;
}

void AtsFutureSpreadMsg::__set_ConMinDiff(const double val) {
  this->ConMinDiff = val;
}

void AtsFutureSpreadMsg::__set_ConMaxDistance(const double val) {
  this->ConMaxDistance = val;
}

void AtsFutureSpreadMsg::__set_HitStatus(const bool val) {
  this->HitStatus = val;
}

void AtsFutureSpreadMsg::__set_ConStatus(const bool val) {
  this->ConStatus = val;
}

void AtsFutureSpreadMsg::__set_ConBuy(const bool val) {
  this->ConBuy = val;
}

void AtsFutureSpreadMsg::__set_ConSell(const bool val) {
  this->ConSell = val;
}

void AtsFutureSpreadMsg::__set_MaxWaitInterval(const int32_t val) {
  this->MaxWaitInterval = val;
}

void AtsFutureSpreadMsg::__set_SpreadPos(const int32_t val) {
  this->SpreadPos = val;
}

void AtsFutureSpreadMsg::__set_Future1Pos(const int32_t val) {
  this->Future1Pos = val;
}

void AtsFutureSpreadMsg::__set_Future2Pos(const int32_t val) {
  this->Future2Pos = val;
}

void AtsFutureSpreadMsg::__set_BidHit(const double val) {
  this->BidHit = val;
}

void AtsFutureSpreadMsg::__set_AskHit(const double val) {
  this->AskHit = val;
}

void AtsFutureSpreadMsg::__set_BidCon(const double val) {
  this->BidCon = val;
}

void AtsFutureSpreadMsg::__set_AskCon(const double val) {
  this->AskCon = val;
}

void AtsFutureSpreadMsg::__set_Fut1Code(const std::string& val) {
  this->Fut1Code = val;
}

void AtsFutureSpreadMsg::__set_Fut2Code(const std::string& val) {
  this->Fut2Code = val;
}

void AtsFutureSpreadMsg::__set_MaxNumOrders(const int32_t val) {
  this->MaxNumOrders = val;
}

void AtsFutureSpreadMsg::__set_MaxPos(const int32_t val) {
  this->MaxPos = val;
}

void AtsFutureSpreadMsg::__set_UseMarketOrder(const bool val) {
  this->UseMarketOrder = val;
}

void AtsFutureSpreadMsg::__set_PosConvex(const double val) {
  this->PosConvex = val;
}

void AtsFutureSpreadMsg::__set_ConvergeRate(const double val) {
  this->ConvergeRate = val;
}

void AtsFutureSpreadMsg::__set_LastKLineTime(const std::string& val) {
  this->LastKLineTime = val;
}

void AtsFutureSpreadMsg::__set_KInterval(const std::string& val) {
  this->KInterval = val;
}

void AtsFutureSpreadMsg::__set_IgnoreUpDnLimit(const bool val) {
  this->IgnoreUpDnLimit = val;
}

void AtsFutureSpreadMsg::__set_Speed(const double val) {
  this->Speed = val;
}

void AtsFutureSpreadMsg::__set_SpeedConvergeRate(const double val) {
  this->SpeedConvergeRate = val;
}

void AtsFutureSpreadMsg::__set_LastSpread(const double val) {
  this->LastSpread = val;
}

void AtsFutureSpreadMsg::__set_Volatility(const double val) {
  this->Volatility = val;
}

void AtsFutureSpreadMsg::__set_MaxVolRange(const double val) {
  this->MaxVolRange = val;
}

void AtsFutureSpreadMsg::__set_RiskDegree(const double val) {
  this->RiskDegree = val;
}

void AtsFutureSpreadMsg::__set_Fut2Cancel(const int32_t val) {
  this->Fut2Cancel = val;
}

void AtsFutureSpreadMsg::__set_FastConvergeRate(const double val) {
  this->FastConvergeRate = val;
}

uint32_t AtsFutureSpreadMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Ats);
          this->__isset.Ats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->FairSpread);
          this->__isset.FairSpread = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->PosShift);
          this->__isset.PosShift = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->AdjustSpread);
          this->__isset.AdjustSpread = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Ratio);
          this->__isset.Ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MinGainHit);
          this->__isset.MinGainHit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MinGainCon);
          this->__isset.MinGainCon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MinGainConExit);
          this->__isset.MinGainConExit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MinInterval);
          this->__isset.MinInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->HitSize);
          this->__isset.HitSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ConSize);
          this->__isset.ConSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ConMinDiff);
          this->__isset.ConMinDiff = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ConMaxDistance);
          this->__isset.ConMaxDistance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->HitStatus);
          this->__isset.HitStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ConStatus);
          this->__isset.ConStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ConBuy);
          this->__isset.ConBuy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ConSell);
          this->__isset.ConSell = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MaxWaitInterval);
          this->__isset.MaxWaitInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->SpreadPos);
          this->__isset.SpreadPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Future1Pos);
          this->__isset.Future1Pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Future2Pos);
          this->__isset.Future2Pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->BidHit);
          this->__isset.BidHit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->AskHit);
          this->__isset.AskHit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->BidCon);
          this->__isset.BidCon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->AskCon);
          this->__isset.AskCon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Fut1Code);
          this->__isset.Fut1Code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Fut2Code);
          this->__isset.Fut2Code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MaxNumOrders);
          this->__isset.MaxNumOrders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MaxPos);
          this->__isset.MaxPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->UseMarketOrder);
          this->__isset.UseMarketOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->PosConvex);
          this->__isset.PosConvex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ConvergeRate);
          this->__isset.ConvergeRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->LastKLineTime);
          this->__isset.LastKLineTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->KInterval);
          this->__isset.KInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 35:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->IgnoreUpDnLimit);
          this->__isset.IgnoreUpDnLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Speed);
          this->__isset.Speed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 37:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->SpeedConvergeRate);
          this->__isset.SpeedConvergeRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 38:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->LastSpread);
          this->__isset.LastSpread = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 39:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Volatility);
          this->__isset.Volatility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MaxVolRange);
          this->__isset.MaxVolRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 41:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->RiskDegree);
          this->__isset.RiskDegree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 42:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Fut2Cancel);
          this->__isset.Fut2Cancel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 43:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->FastConvergeRate);
          this->__isset.FastConvergeRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AtsFutureSpreadMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AtsFutureSpreadMsg");

  xfer += oprot->writeFieldBegin("Ats", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Ats);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("FairSpread", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->FairSpread);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("PosShift", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->PosShift);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AdjustSpread", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->AdjustSpread);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Ratio", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->Ratio);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinGainHit", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->MinGainHit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinGainCon", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->MinGainCon);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinGainConExit", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->MinGainConExit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinInterval", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->MinInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("HitSize", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->HitSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConSize", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->ConSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConMinDiff", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->ConMinDiff);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConMaxDistance", ::apache::thrift::protocol::T_DOUBLE, 13);
  xfer += oprot->writeDouble(this->ConMaxDistance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("HitStatus", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->HitStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConStatus", ::apache::thrift::protocol::T_BOOL, 15);
  xfer += oprot->writeBool(this->ConStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConBuy", ::apache::thrift::protocol::T_BOOL, 16);
  xfer += oprot->writeBool(this->ConBuy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConSell", ::apache::thrift::protocol::T_BOOL, 17);
  xfer += oprot->writeBool(this->ConSell);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxWaitInterval", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32(this->MaxWaitInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("SpreadPos", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->SpreadPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Future1Pos", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->Future1Pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Future2Pos", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->Future2Pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("BidHit", ::apache::thrift::protocol::T_DOUBLE, 22);
  xfer += oprot->writeDouble(this->BidHit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AskHit", ::apache::thrift::protocol::T_DOUBLE, 23);
  xfer += oprot->writeDouble(this->AskHit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("BidCon", ::apache::thrift::protocol::T_DOUBLE, 24);
  xfer += oprot->writeDouble(this->BidCon);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AskCon", ::apache::thrift::protocol::T_DOUBLE, 25);
  xfer += oprot->writeDouble(this->AskCon);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Fut1Code", ::apache::thrift::protocol::T_STRING, 26);
  xfer += oprot->writeString(this->Fut1Code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Fut2Code", ::apache::thrift::protocol::T_STRING, 27);
  xfer += oprot->writeString(this->Fut2Code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxNumOrders", ::apache::thrift::protocol::T_I32, 28);
  xfer += oprot->writeI32(this->MaxNumOrders);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxPos", ::apache::thrift::protocol::T_I32, 29);
  xfer += oprot->writeI32(this->MaxPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("UseMarketOrder", ::apache::thrift::protocol::T_BOOL, 30);
  xfer += oprot->writeBool(this->UseMarketOrder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("PosConvex", ::apache::thrift::protocol::T_DOUBLE, 31);
  xfer += oprot->writeDouble(this->PosConvex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConvergeRate", ::apache::thrift::protocol::T_DOUBLE, 32);
  xfer += oprot->writeDouble(this->ConvergeRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("LastKLineTime", ::apache::thrift::protocol::T_STRING, 33);
  xfer += oprot->writeString(this->LastKLineTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("KInterval", ::apache::thrift::protocol::T_STRING, 34);
  xfer += oprot->writeString(this->KInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("IgnoreUpDnLimit", ::apache::thrift::protocol::T_BOOL, 35);
  xfer += oprot->writeBool(this->IgnoreUpDnLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Speed", ::apache::thrift::protocol::T_DOUBLE, 36);
  xfer += oprot->writeDouble(this->Speed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("SpeedConvergeRate", ::apache::thrift::protocol::T_DOUBLE, 37);
  xfer += oprot->writeDouble(this->SpeedConvergeRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("LastSpread", ::apache::thrift::protocol::T_DOUBLE, 38);
  xfer += oprot->writeDouble(this->LastSpread);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Volatility", ::apache::thrift::protocol::T_DOUBLE, 39);
  xfer += oprot->writeDouble(this->Volatility);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxVolRange", ::apache::thrift::protocol::T_DOUBLE, 40);
  xfer += oprot->writeDouble(this->MaxVolRange);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("RiskDegree", ::apache::thrift::protocol::T_DOUBLE, 41);
  xfer += oprot->writeDouble(this->RiskDegree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Fut2Cancel", ::apache::thrift::protocol::T_I32, 42);
  xfer += oprot->writeI32(this->Fut2Cancel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("FastConvergeRate", ::apache::thrift::protocol::T_DOUBLE, 43);
  xfer += oprot->writeDouble(this->FastConvergeRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AtsFutureSpreadMsg &a, AtsFutureSpreadMsg &b) {
  using ::std::swap;
  swap(a.Ats, b.Ats);
  swap(a.FairSpread, b.FairSpread);
  swap(a.PosShift, b.PosShift);
  swap(a.AdjustSpread, b.AdjustSpread);
  swap(a.Ratio, b.Ratio);
  swap(a.MinGainHit, b.MinGainHit);
  swap(a.MinGainCon, b.MinGainCon);
  swap(a.MinGainConExit, b.MinGainConExit);
  swap(a.MinInterval, b.MinInterval);
  swap(a.HitSize, b.HitSize);
  swap(a.ConSize, b.ConSize);
  swap(a.ConMinDiff, b.ConMinDiff);
  swap(a.ConMaxDistance, b.ConMaxDistance);
  swap(a.HitStatus, b.HitStatus);
  swap(a.ConStatus, b.ConStatus);
  swap(a.ConBuy, b.ConBuy);
  swap(a.ConSell, b.ConSell);
  swap(a.MaxWaitInterval, b.MaxWaitInterval);
  swap(a.SpreadPos, b.SpreadPos);
  swap(a.Future1Pos, b.Future1Pos);
  swap(a.Future2Pos, b.Future2Pos);
  swap(a.BidHit, b.BidHit);
  swap(a.AskHit, b.AskHit);
  swap(a.BidCon, b.BidCon);
  swap(a.AskCon, b.AskCon);
  swap(a.Fut1Code, b.Fut1Code);
  swap(a.Fut2Code, b.Fut2Code);
  swap(a.MaxNumOrders, b.MaxNumOrders);
  swap(a.MaxPos, b.MaxPos);
  swap(a.UseMarketOrder, b.UseMarketOrder);
  swap(a.PosConvex, b.PosConvex);
  swap(a.ConvergeRate, b.ConvergeRate);
  swap(a.LastKLineTime, b.LastKLineTime);
  swap(a.KInterval, b.KInterval);
  swap(a.IgnoreUpDnLimit, b.IgnoreUpDnLimit);
  swap(a.Speed, b.Speed);
  swap(a.SpeedConvergeRate, b.SpeedConvergeRate);
  swap(a.LastSpread, b.LastSpread);
  swap(a.Volatility, b.Volatility);
  swap(a.MaxVolRange, b.MaxVolRange);
  swap(a.RiskDegree, b.RiskDegree);
  swap(a.Fut2Cancel, b.Fut2Cancel);
  swap(a.FastConvergeRate, b.FastConvergeRate);
  swap(a.__isset, b.__isset);
}

AtsFutureSpreadMsg::AtsFutureSpreadMsg(const AtsFutureSpreadMsg& other4) {
  Ats = other4.Ats;
  FairSpread = other4.FairSpread;
  PosShift = other4.PosShift;
  AdjustSpread = other4.AdjustSpread;
  Ratio = other4.Ratio;
  MinGainHit = other4.MinGainHit;
  MinGainCon = other4.MinGainCon;
  MinGainConExit = other4.MinGainConExit;
  MinInterval = other4.MinInterval;
  HitSize = other4.HitSize;
  ConSize = other4.ConSize;
  ConMinDiff = other4.ConMinDiff;
  ConMaxDistance = other4.ConMaxDistance;
  HitStatus = other4.HitStatus;
  ConStatus = other4.ConStatus;
  ConBuy = other4.ConBuy;
  ConSell = other4.ConSell;
  MaxWaitInterval = other4.MaxWaitInterval;
  SpreadPos = other4.SpreadPos;
  Future1Pos = other4.Future1Pos;
  Future2Pos = other4.Future2Pos;
  BidHit = other4.BidHit;
  AskHit = other4.AskHit;
  BidCon = other4.BidCon;
  AskCon = other4.AskCon;
  Fut1Code = other4.Fut1Code;
  Fut2Code = other4.Fut2Code;
  MaxNumOrders = other4.MaxNumOrders;
  MaxPos = other4.MaxPos;
  UseMarketOrder = other4.UseMarketOrder;
  PosConvex = other4.PosConvex;
  ConvergeRate = other4.ConvergeRate;
  LastKLineTime = other4.LastKLineTime;
  KInterval = other4.KInterval;
  IgnoreUpDnLimit = other4.IgnoreUpDnLimit;
  Speed = other4.Speed;
  SpeedConvergeRate = other4.SpeedConvergeRate;
  LastSpread = other4.LastSpread;
  Volatility = other4.Volatility;
  MaxVolRange = other4.MaxVolRange;
  RiskDegree = other4.RiskDegree;
  Fut2Cancel = other4.Fut2Cancel;
  FastConvergeRate = other4.FastConvergeRate;
  __isset = other4.__isset;
}
AtsFutureSpreadMsg& AtsFutureSpreadMsg::operator=(const AtsFutureSpreadMsg& other5) {
  Ats = other5.Ats;
  FairSpread = other5.FairSpread;
  PosShift = other5.PosShift;
  AdjustSpread = other5.AdjustSpread;
  Ratio = other5.Ratio;
  MinGainHit = other5.MinGainHit;
  MinGainCon = other5.MinGainCon;
  MinGainConExit = other5.MinGainConExit;
  MinInterval = other5.MinInterval;
  HitSize = other5.HitSize;
  ConSize = other5.ConSize;
  ConMinDiff = other5.ConMinDiff;
  ConMaxDistance = other5.ConMaxDistance;
  HitStatus = other5.HitStatus;
  ConStatus = other5.ConStatus;
  ConBuy = other5.ConBuy;
  ConSell = other5.ConSell;
  MaxWaitInterval = other5.MaxWaitInterval;
  SpreadPos = other5.SpreadPos;
  Future1Pos = other5.Future1Pos;
  Future2Pos = other5.Future2Pos;
  BidHit = other5.BidHit;
  AskHit = other5.AskHit;
  BidCon = other5.BidCon;
  AskCon = other5.AskCon;
  Fut1Code = other5.Fut1Code;
  Fut2Code = other5.Fut2Code;
  MaxNumOrders = other5.MaxNumOrders;
  MaxPos = other5.MaxPos;
  UseMarketOrder = other5.UseMarketOrder;
  PosConvex = other5.PosConvex;
  ConvergeRate = other5.ConvergeRate;
  LastKLineTime = other5.LastKLineTime;
  KInterval = other5.KInterval;
  IgnoreUpDnLimit = other5.IgnoreUpDnLimit;
  Speed = other5.Speed;
  SpeedConvergeRate = other5.SpeedConvergeRate;
  LastSpread = other5.LastSpread;
  Volatility = other5.Volatility;
  MaxVolRange = other5.MaxVolRange;
  RiskDegree = other5.RiskDegree;
  Fut2Cancel = other5.Fut2Cancel;
  FastConvergeRate = other5.FastConvergeRate;
  __isset = other5.__isset;
  return *this;
}
void AtsFutureSpreadMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AtsFutureSpreadMsg(";
  out << "Ats=" << to_string(Ats);
  out << ", " << "FairSpread=" << to_string(FairSpread);
  out << ", " << "PosShift=" << to_string(PosShift);
  out << ", " << "AdjustSpread=" << to_string(AdjustSpread);
  out << ", " << "Ratio=" << to_string(Ratio);
  out << ", " << "MinGainHit=" << to_string(MinGainHit);
  out << ", " << "MinGainCon=" << to_string(MinGainCon);
  out << ", " << "MinGainConExit=" << to_string(MinGainConExit);
  out << ", " << "MinInterval=" << to_string(MinInterval);
  out << ", " << "HitSize=" << to_string(HitSize);
  out << ", " << "ConSize=" << to_string(ConSize);
  out << ", " << "ConMinDiff=" << to_string(ConMinDiff);
  out << ", " << "ConMaxDistance=" << to_string(ConMaxDistance);
  out << ", " << "HitStatus=" << to_string(HitStatus);
  out << ", " << "ConStatus=" << to_string(ConStatus);
  out << ", " << "ConBuy=" << to_string(ConBuy);
  out << ", " << "ConSell=" << to_string(ConSell);
  out << ", " << "MaxWaitInterval=" << to_string(MaxWaitInterval);
  out << ", " << "SpreadPos=" << to_string(SpreadPos);
  out << ", " << "Future1Pos=" << to_string(Future1Pos);
  out << ", " << "Future2Pos=" << to_string(Future2Pos);
  out << ", " << "BidHit=" << to_string(BidHit);
  out << ", " << "AskHit=" << to_string(AskHit);
  out << ", " << "BidCon=" << to_string(BidCon);
  out << ", " << "AskCon=" << to_string(AskCon);
  out << ", " << "Fut1Code=" << to_string(Fut1Code);
  out << ", " << "Fut2Code=" << to_string(Fut2Code);
  out << ", " << "MaxNumOrders=" << to_string(MaxNumOrders);
  out << ", " << "MaxPos=" << to_string(MaxPos);
  out << ", " << "UseMarketOrder=" << to_string(UseMarketOrder);
  out << ", " << "PosConvex=" << to_string(PosConvex);
  out << ", " << "ConvergeRate=" << to_string(ConvergeRate);
  out << ", " << "LastKLineTime=" << to_string(LastKLineTime);
  out << ", " << "KInterval=" << to_string(KInterval);
  out << ", " << "IgnoreUpDnLimit=" << to_string(IgnoreUpDnLimit);
  out << ", " << "Speed=" << to_string(Speed);
  out << ", " << "SpeedConvergeRate=" << to_string(SpeedConvergeRate);
  out << ", " << "LastSpread=" << to_string(LastSpread);
  out << ", " << "Volatility=" << to_string(Volatility);
  out << ", " << "MaxVolRange=" << to_string(MaxVolRange);
  out << ", " << "RiskDegree=" << to_string(RiskDegree);
  out << ", " << "Fut2Cancel=" << to_string(Fut2Cancel);
  out << ", " << "FastConvergeRate=" << to_string(FastConvergeRate);
  out << ")";
}


KlineConfigMsg::~KlineConfigMsg() throw() {
}


void KlineConfigMsg::__set_KlineNum(const int32_t val) {
  this->KlineNum = val;
}

void KlineConfigMsg::__set_KlineDur(const int32_t val) {
  this->KlineDur = val;
}

uint32_t KlineConfigMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->KlineNum);
          this->__isset.KlineNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->KlineDur);
          this->__isset.KlineDur = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KlineConfigMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KlineConfigMsg");

  xfer += oprot->writeFieldBegin("KlineNum", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->KlineNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("KlineDur", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->KlineDur);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KlineConfigMsg &a, KlineConfigMsg &b) {
  using ::std::swap;
  swap(a.KlineNum, b.KlineNum);
  swap(a.KlineDur, b.KlineDur);
  swap(a.__isset, b.__isset);
}

KlineConfigMsg::KlineConfigMsg(const KlineConfigMsg& other6) {
  KlineNum = other6.KlineNum;
  KlineDur = other6.KlineDur;
  __isset = other6.__isset;
}
KlineConfigMsg& KlineConfigMsg::operator=(const KlineConfigMsg& other7) {
  KlineNum = other7.KlineNum;
  KlineDur = other7.KlineDur;
  __isset = other7.__isset;
  return *this;
}
void KlineConfigMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KlineConfigMsg(";
  out << "KlineNum=" << to_string(KlineNum);
  out << ", " << "KlineDur=" << to_string(KlineDur);
  out << ")";
}


TWAPDataMsg::~TWAPDataMsg() throw() {
}


void TWAPDataMsg::__set_Time(const int32_t val) {
  this->Time = val;
}

void TWAPDataMsg::__set_Alpha(const double val) {
  this->Alpha = val;
}

void TWAPDataMsg::__set_Max_Order_Size(const int32_t val) {
  this->Max_Order_Size = val;
}

void TWAPDataMsg::__set_Min_Order_Size(const int32_t val) {
  this->Min_Order_Size = val;
}

void TWAPDataMsg::__set_Sleep_Time(const int32_t val) {
  this->Sleep_Time = val;
}

uint32_t TWAPDataMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Time);
          this->__isset.Time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Alpha);
          this->__isset.Alpha = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Max_Order_Size);
          this->__isset.Max_Order_Size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Min_Order_Size);
          this->__isset.Min_Order_Size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Sleep_Time);
          this->__isset.Sleep_Time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TWAPDataMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TWAPDataMsg");

  xfer += oprot->writeFieldBegin("Time", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->Time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Alpha", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Alpha);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Max_Order_Size", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->Max_Order_Size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Min_Order_Size", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->Min_Order_Size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Sleep_Time", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->Sleep_Time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TWAPDataMsg &a, TWAPDataMsg &b) {
  using ::std::swap;
  swap(a.Time, b.Time);
  swap(a.Alpha, b.Alpha);
  swap(a.Max_Order_Size, b.Max_Order_Size);
  swap(a.Min_Order_Size, b.Min_Order_Size);
  swap(a.Sleep_Time, b.Sleep_Time);
  swap(a.__isset, b.__isset);
}

TWAPDataMsg::TWAPDataMsg(const TWAPDataMsg& other8) {
  Time = other8.Time;
  Alpha = other8.Alpha;
  Max_Order_Size = other8.Max_Order_Size;
  Min_Order_Size = other8.Min_Order_Size;
  Sleep_Time = other8.Sleep_Time;
  __isset = other8.__isset;
}
TWAPDataMsg& TWAPDataMsg::operator=(const TWAPDataMsg& other9) {
  Time = other9.Time;
  Alpha = other9.Alpha;
  Max_Order_Size = other9.Max_Order_Size;
  Min_Order_Size = other9.Min_Order_Size;
  Sleep_Time = other9.Sleep_Time;
  __isset = other9.__isset;
  return *this;
}
void TWAPDataMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TWAPDataMsg(";
  out << "Time=" << to_string(Time);
  out << ", " << "Alpha=" << to_string(Alpha);
  out << ", " << "Max_Order_Size=" << to_string(Max_Order_Size);
  out << ", " << "Min_Order_Size=" << to_string(Min_Order_Size);
  out << ", " << "Sleep_Time=" << to_string(Sleep_Time);
  out << ")";
}


KlineDataMsg::~KlineDataMsg() throw() {
}


void KlineDataMsg::__set_Time(const std::string& val) {
  this->Time = val;
}

void KlineDataMsg::__set_Open(const double val) {
  this->Open = val;
}

void KlineDataMsg::__set_High(const double val) {
  this->High = val;
}

void KlineDataMsg::__set_Low(const double val) {
  this->Low = val;
}

void KlineDataMsg::__set_Close(const double val) {
  this->Close = val;
}

void KlineDataMsg::__set_TR(const double val) {
  this->TR = val;
}

void KlineDataMsg::__set_Signal(const int32_t val) {
  this->Signal = val;
}

uint32_t KlineDataMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Time);
          this->__isset.Time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Open);
          this->__isset.Open = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->High);
          this->__isset.High = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Low);
          this->__isset.Low = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Close);
          this->__isset.Close = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TR);
          this->__isset.TR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Signal);
          this->__isset.Signal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KlineDataMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KlineDataMsg");

  xfer += oprot->writeFieldBegin("Time", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Open", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Open);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("High", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->High);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Low", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->Low);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Close", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->Close);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TR", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->TR);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Signal", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->Signal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KlineDataMsg &a, KlineDataMsg &b) {
  using ::std::swap;
  swap(a.Time, b.Time);
  swap(a.Open, b.Open);
  swap(a.High, b.High);
  swap(a.Low, b.Low);
  swap(a.Close, b.Close);
  swap(a.TR, b.TR);
  swap(a.Signal, b.Signal);
  swap(a.__isset, b.__isset);
}

KlineDataMsg::KlineDataMsg(const KlineDataMsg& other10) {
  Time = other10.Time;
  Open = other10.Open;
  High = other10.High;
  Low = other10.Low;
  Close = other10.Close;
  TR = other10.TR;
  Signal = other10.Signal;
  __isset = other10.__isset;
}
KlineDataMsg& KlineDataMsg::operator=(const KlineDataMsg& other11) {
  Time = other11.Time;
  Open = other11.Open;
  High = other11.High;
  Low = other11.Low;
  Close = other11.Close;
  TR = other11.TR;
  Signal = other11.Signal;
  __isset = other11.__isset;
  return *this;
}
void KlineDataMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KlineDataMsg(";
  out << "Time=" << to_string(Time);
  out << ", " << "Open=" << to_string(Open);
  out << ", " << "High=" << to_string(High);
  out << ", " << "Low=" << to_string(Low);
  out << ", " << "Close=" << to_string(Close);
  out << ", " << "TR=" << to_string(TR);
  out << ", " << "Signal=" << to_string(Signal);
  out << ")";
}


TurtleAlgoMsg::~TurtleAlgoMsg() throw() {
}


void TurtleAlgoMsg::__set_LastKLineTime(const std::string& val) {
  this->LastKLineTime = val;
}

void TurtleAlgoMsg::__set_KInterval(const std::string& val) {
  this->KInterval = val;
}

void TurtleAlgoMsg::__set_PriceDatas(const std::vector<KlineDataMsg> & val) {
  this->PriceDatas = val;
}

void TurtleAlgoMsg::__set_CurrentPrice(const KlineDataMsg& val) {
  this->CurrentPrice = val;
}

void TurtleAlgoMsg::__set_NumOpenKline(const int32_t val) {
  this->NumOpenKline = val;
}

void TurtleAlgoMsg::__set_NumCloseKline(const int32_t val) {
  this->NumCloseKline = val;
}

void TurtleAlgoMsg::__set_MA_Fast(const double val) {
  this->MA_Fast = val;
}

void TurtleAlgoMsg::__set_MA_Slow(const double val) {
  this->MA_Slow = val;
}

void TurtleAlgoMsg::__set_Lambda_Fast(const double val) {
  this->Lambda_Fast = val;
}

void TurtleAlgoMsg::__set_Lambda_Slow(const double val) {
  this->Lambda_Slow = val;
}

void TurtleAlgoMsg::__set_Signal(const int32_t val) {
  this->Signal = val;
}

void TurtleAlgoMsg::__set_ATR(const double val) {
  this->ATR = val;
}

void TurtleAlgoMsg::__set_PosRatio(const double val) {
  this->PosRatio = val;
}

void TurtleAlgoMsg::__set_LastUpdatePrice(const double val) {
  this->LastUpdatePrice = val;
}

void TurtleAlgoMsg::__set_MaxPosLimit(const int32_t val) {
  this->MaxPosLimit = val;
}

void TurtleAlgoMsg::__set_UpdateKline(const bool val) {
  this->UpdateKline = val;
}

void TurtleAlgoMsg::__set_EnableTurtle(const bool val) {
  this->EnableTurtle = val;
}

void TurtleAlgoMsg::__set_Instr_Code(const std::string& val) {
  this->Instr_Code = val;
}

uint32_t TurtleAlgoMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->LastKLineTime);
          this->__isset.LastKLineTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->KInterval);
          this->__isset.KInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->PriceDatas.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->PriceDatas.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->PriceDatas[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.PriceDatas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->CurrentPrice.read(iprot);
          this->__isset.CurrentPrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->NumOpenKline);
          this->__isset.NumOpenKline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->NumCloseKline);
          this->__isset.NumCloseKline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MA_Fast);
          this->__isset.MA_Fast = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MA_Slow);
          this->__isset.MA_Slow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Lambda_Fast);
          this->__isset.Lambda_Fast = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Lambda_Slow);
          this->__isset.Lambda_Slow = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Signal);
          this->__isset.Signal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ATR);
          this->__isset.ATR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->PosRatio);
          this->__isset.PosRatio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->LastUpdatePrice);
          this->__isset.LastUpdatePrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MaxPosLimit);
          this->__isset.MaxPosLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->UpdateKline);
          this->__isset.UpdateKline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->EnableTurtle);
          this->__isset.EnableTurtle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Instr_Code);
          this->__isset.Instr_Code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TurtleAlgoMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TurtleAlgoMsg");

  xfer += oprot->writeFieldBegin("LastKLineTime", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->LastKLineTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("KInterval", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->KInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("PriceDatas", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->PriceDatas.size()));
    std::vector<KlineDataMsg> ::const_iterator _iter17;
    for (_iter17 = this->PriceDatas.begin(); _iter17 != this->PriceDatas.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("CurrentPrice", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->CurrentPrice.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("NumOpenKline", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->NumOpenKline);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("NumCloseKline", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->NumCloseKline);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MA_Fast", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->MA_Fast);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MA_Slow", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->MA_Slow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Lambda_Fast", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->Lambda_Fast);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Lambda_Slow", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->Lambda_Slow);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Signal", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->Signal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ATR", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->ATR);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("PosRatio", ::apache::thrift::protocol::T_DOUBLE, 13);
  xfer += oprot->writeDouble(this->PosRatio);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("LastUpdatePrice", ::apache::thrift::protocol::T_DOUBLE, 14);
  xfer += oprot->writeDouble(this->LastUpdatePrice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxPosLimit", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->MaxPosLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("UpdateKline", ::apache::thrift::protocol::T_BOOL, 16);
  xfer += oprot->writeBool(this->UpdateKline);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("EnableTurtle", ::apache::thrift::protocol::T_BOOL, 17);
  xfer += oprot->writeBool(this->EnableTurtle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Instr_Code", ::apache::thrift::protocol::T_STRING, 18);
  xfer += oprot->writeString(this->Instr_Code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TurtleAlgoMsg &a, TurtleAlgoMsg &b) {
  using ::std::swap;
  swap(a.LastKLineTime, b.LastKLineTime);
  swap(a.KInterval, b.KInterval);
  swap(a.PriceDatas, b.PriceDatas);
  swap(a.CurrentPrice, b.CurrentPrice);
  swap(a.NumOpenKline, b.NumOpenKline);
  swap(a.NumCloseKline, b.NumCloseKline);
  swap(a.MA_Fast, b.MA_Fast);
  swap(a.MA_Slow, b.MA_Slow);
  swap(a.Lambda_Fast, b.Lambda_Fast);
  swap(a.Lambda_Slow, b.Lambda_Slow);
  swap(a.Signal, b.Signal);
  swap(a.ATR, b.ATR);
  swap(a.PosRatio, b.PosRatio);
  swap(a.LastUpdatePrice, b.LastUpdatePrice);
  swap(a.MaxPosLimit, b.MaxPosLimit);
  swap(a.UpdateKline, b.UpdateKline);
  swap(a.EnableTurtle, b.EnableTurtle);
  swap(a.Instr_Code, b.Instr_Code);
  swap(a.__isset, b.__isset);
}

TurtleAlgoMsg::TurtleAlgoMsg(const TurtleAlgoMsg& other18) {
  LastKLineTime = other18.LastKLineTime;
  KInterval = other18.KInterval;
  PriceDatas = other18.PriceDatas;
  CurrentPrice = other18.CurrentPrice;
  NumOpenKline = other18.NumOpenKline;
  NumCloseKline = other18.NumCloseKline;
  MA_Fast = other18.MA_Fast;
  MA_Slow = other18.MA_Slow;
  Lambda_Fast = other18.Lambda_Fast;
  Lambda_Slow = other18.Lambda_Slow;
  Signal = other18.Signal;
  ATR = other18.ATR;
  PosRatio = other18.PosRatio;
  LastUpdatePrice = other18.LastUpdatePrice;
  MaxPosLimit = other18.MaxPosLimit;
  UpdateKline = other18.UpdateKline;
  EnableTurtle = other18.EnableTurtle;
  Instr_Code = other18.Instr_Code;
  __isset = other18.__isset;
}
TurtleAlgoMsg& TurtleAlgoMsg::operator=(const TurtleAlgoMsg& other19) {
  LastKLineTime = other19.LastKLineTime;
  KInterval = other19.KInterval;
  PriceDatas = other19.PriceDatas;
  CurrentPrice = other19.CurrentPrice;
  NumOpenKline = other19.NumOpenKline;
  NumCloseKline = other19.NumCloseKline;
  MA_Fast = other19.MA_Fast;
  MA_Slow = other19.MA_Slow;
  Lambda_Fast = other19.Lambda_Fast;
  Lambda_Slow = other19.Lambda_Slow;
  Signal = other19.Signal;
  ATR = other19.ATR;
  PosRatio = other19.PosRatio;
  LastUpdatePrice = other19.LastUpdatePrice;
  MaxPosLimit = other19.MaxPosLimit;
  UpdateKline = other19.UpdateKline;
  EnableTurtle = other19.EnableTurtle;
  Instr_Code = other19.Instr_Code;
  __isset = other19.__isset;
  return *this;
}
void TurtleAlgoMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TurtleAlgoMsg(";
  out << "LastKLineTime=" << to_string(LastKLineTime);
  out << ", " << "KInterval=" << to_string(KInterval);
  out << ", " << "PriceDatas=" << to_string(PriceDatas);
  out << ", " << "CurrentPrice=" << to_string(CurrentPrice);
  out << ", " << "NumOpenKline=" << to_string(NumOpenKline);
  out << ", " << "NumCloseKline=" << to_string(NumCloseKline);
  out << ", " << "MA_Fast=" << to_string(MA_Fast);
  out << ", " << "MA_Slow=" << to_string(MA_Slow);
  out << ", " << "Lambda_Fast=" << to_string(Lambda_Fast);
  out << ", " << "Lambda_Slow=" << to_string(Lambda_Slow);
  out << ", " << "Signal=" << to_string(Signal);
  out << ", " << "ATR=" << to_string(ATR);
  out << ", " << "PosRatio=" << to_string(PosRatio);
  out << ", " << "LastUpdatePrice=" << to_string(LastUpdatePrice);
  out << ", " << "MaxPosLimit=" << to_string(MaxPosLimit);
  out << ", " << "UpdateKline=" << to_string(UpdateKline);
  out << ", " << "EnableTurtle=" << to_string(EnableTurtle);
  out << ", " << "Instr_Code=" << to_string(Instr_Code);
  out << ")";
}


CTAAtsMsg::~CTAAtsMsg() throw() {
}


void CTAAtsMsg::__set_Ats(const  ::AtsGeneral::AtsMsg& val) {
  this->Ats = val;
}

void CTAAtsMsg::__set_AllFutures(const std::vector<IAFutureMsg> & val) {
  this->AllFutures = val;
}

void CTAAtsMsg::__set_KeepOrders(const bool val) {
  this->KeepOrders = val;
}

void CTAAtsMsg::__set_ForceOpen(const bool val) {
  this->ForceOpen = val;
}

void CTAAtsMsg::__set_AtsSpread(const AtsFutureSpreadMsg& val) {
  this->AtsSpread = val;
}

void CTAAtsMsg::__set_AtsIntraDataCols(const std::vector<std::string> & val) {
  this->AtsIntraDataCols = val;
}

void CTAAtsMsg::__set_FeedsourcesStr(const std::string& val) {
  this->FeedsourcesStr = val;
}

void CTAAtsMsg::__set_ConnectionsStr(const std::string& val) {
  this->ConnectionsStr = val;
}

void CTAAtsMsg::__set_Underlyings(const std::vector< ::AtsGeneral::UnderlyingMsg> & val) {
  this->Underlyings = val;
}

void CTAAtsMsg::__set_DoFutureMarketMaker(const bool val) {
  this->DoFutureMarketMaker = val;
}

void CTAAtsMsg::__set_MarketMakerCanReduce(const bool val) {
  this->MarketMakerCanReduce = val;
}

void CTAAtsMsg::__set_Turtle(const TurtleAlgoMsg& val) {
  this->Turtle = val;
}

uint32_t CTAAtsMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Ats.read(iprot);
          this->__isset.Ats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->AllFutures.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->AllFutures.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->AllFutures[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.AllFutures = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->KeepOrders);
          this->__isset.KeepOrders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ForceOpen);
          this->__isset.ForceOpen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->AtsSpread.read(iprot);
          this->__isset.AtsSpread = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->AtsIntraDataCols.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->AtsIntraDataCols.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += iprot->readString(this->AtsIntraDataCols[_i29]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.AtsIntraDataCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->FeedsourcesStr);
          this->__isset.FeedsourcesStr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ConnectionsStr);
          this->__isset.ConnectionsStr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Underlyings.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->Underlyings.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += this->Underlyings[_i34].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Underlyings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->DoFutureMarketMaker);
          this->__isset.DoFutureMarketMaker = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->MarketMakerCanReduce);
          this->__isset.MarketMakerCanReduce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Turtle.read(iprot);
          this->__isset.Turtle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAAtsMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAAtsMsg");

  xfer += oprot->writeFieldBegin("Ats", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->Ats.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AllFutures", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->AllFutures.size()));
    std::vector<IAFutureMsg> ::const_iterator _iter35;
    for (_iter35 = this->AllFutures.begin(); _iter35 != this->AllFutures.end(); ++_iter35)
    {
      xfer += (*_iter35).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("KeepOrders", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->KeepOrders);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ForceOpen", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->ForceOpen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AtsSpread", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->AtsSpread.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AtsIntraDataCols", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->AtsIntraDataCols.size()));
    std::vector<std::string> ::const_iterator _iter36;
    for (_iter36 = this->AtsIntraDataCols.begin(); _iter36 != this->AtsIntraDataCols.end(); ++_iter36)
    {
      xfer += oprot->writeString((*_iter36));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("FeedsourcesStr", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->FeedsourcesStr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConnectionsStr", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->ConnectionsStr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Underlyings", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Underlyings.size()));
    std::vector< ::AtsGeneral::UnderlyingMsg> ::const_iterator _iter37;
    for (_iter37 = this->Underlyings.begin(); _iter37 != this->Underlyings.end(); ++_iter37)
    {
      xfer += (*_iter37).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("DoFutureMarketMaker", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->DoFutureMarketMaker);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MarketMakerCanReduce", ::apache::thrift::protocol::T_BOOL, 11);
  xfer += oprot->writeBool(this->MarketMakerCanReduce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Turtle", ::apache::thrift::protocol::T_STRUCT, 12);
  xfer += this->Turtle.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CTAAtsMsg &a, CTAAtsMsg &b) {
  using ::std::swap;
  swap(a.Ats, b.Ats);
  swap(a.AllFutures, b.AllFutures);
  swap(a.KeepOrders, b.KeepOrders);
  swap(a.ForceOpen, b.ForceOpen);
  swap(a.AtsSpread, b.AtsSpread);
  swap(a.AtsIntraDataCols, b.AtsIntraDataCols);
  swap(a.FeedsourcesStr, b.FeedsourcesStr);
  swap(a.ConnectionsStr, b.ConnectionsStr);
  swap(a.Underlyings, b.Underlyings);
  swap(a.DoFutureMarketMaker, b.DoFutureMarketMaker);
  swap(a.MarketMakerCanReduce, b.MarketMakerCanReduce);
  swap(a.Turtle, b.Turtle);
  swap(a.__isset, b.__isset);
}

CTAAtsMsg::CTAAtsMsg(const CTAAtsMsg& other38) {
  Ats = other38.Ats;
  AllFutures = other38.AllFutures;
  KeepOrders = other38.KeepOrders;
  ForceOpen = other38.ForceOpen;
  AtsSpread = other38.AtsSpread;
  AtsIntraDataCols = other38.AtsIntraDataCols;
  FeedsourcesStr = other38.FeedsourcesStr;
  ConnectionsStr = other38.ConnectionsStr;
  Underlyings = other38.Underlyings;
  DoFutureMarketMaker = other38.DoFutureMarketMaker;
  MarketMakerCanReduce = other38.MarketMakerCanReduce;
  Turtle = other38.Turtle;
  __isset = other38.__isset;
}
CTAAtsMsg& CTAAtsMsg::operator=(const CTAAtsMsg& other39) {
  Ats = other39.Ats;
  AllFutures = other39.AllFutures;
  KeepOrders = other39.KeepOrders;
  ForceOpen = other39.ForceOpen;
  AtsSpread = other39.AtsSpread;
  AtsIntraDataCols = other39.AtsIntraDataCols;
  FeedsourcesStr = other39.FeedsourcesStr;
  ConnectionsStr = other39.ConnectionsStr;
  Underlyings = other39.Underlyings;
  DoFutureMarketMaker = other39.DoFutureMarketMaker;
  MarketMakerCanReduce = other39.MarketMakerCanReduce;
  Turtle = other39.Turtle;
  __isset = other39.__isset;
  return *this;
}
void CTAAtsMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CTAAtsMsg(";
  out << "Ats=" << to_string(Ats);
  out << ", " << "AllFutures=" << to_string(AllFutures);
  out << ", " << "KeepOrders=" << to_string(KeepOrders);
  out << ", " << "ForceOpen=" << to_string(ForceOpen);
  out << ", " << "AtsSpread=" << to_string(AtsSpread);
  out << ", " << "AtsIntraDataCols=" << to_string(AtsIntraDataCols);
  out << ", " << "FeedsourcesStr=" << to_string(FeedsourcesStr);
  out << ", " << "ConnectionsStr=" << to_string(ConnectionsStr);
  out << ", " << "Underlyings=" << to_string(Underlyings);
  out << ", " << "DoFutureMarketMaker=" << to_string(DoFutureMarketMaker);
  out << ", " << "MarketMakerCanReduce=" << to_string(MarketMakerCanReduce);
  out << ", " << "Turtle=" << to_string(Turtle);
  out << ")";
}

} // namespace
