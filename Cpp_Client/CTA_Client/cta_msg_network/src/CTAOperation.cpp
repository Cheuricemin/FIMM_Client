/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "CTAOperation.h"

namespace CTAMsg {


CTAOperation_SetFutureSpreadHitStatus_args::~CTAOperation_SetFutureSpreadHitStatus_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadHitStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadHitStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadHitStatus_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadHitStatus_pargs::~CTAOperation_SetFutureSpreadHitStatus_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadHitStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadHitStatus_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->status)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadHitStatus_result::~CTAOperation_SetFutureSpreadHitStatus_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadHitStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadHitStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadHitStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadHitStatus_presult::~CTAOperation_SetFutureSpreadHitStatus_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadHitStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadConStatus_args::~CTAOperation_SetFutureSpreadConStatus_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConStatus_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConStatus_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConStatus_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConStatus_pargs::~CTAOperation_SetFutureSpreadConStatus_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConStatus_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConStatus_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->status)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConStatus_result::~CTAOperation_SetFutureSpreadConStatus_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConStatus_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConStatus_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConStatus_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConStatus_presult::~CTAOperation_SetFutureSpreadConStatus_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConStatus_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadConBuy_args::~CTAOperation_SetFutureSpreadConBuy_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConBuy_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConBuy_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConBuy_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConBuy_pargs::~CTAOperation_SetFutureSpreadConBuy_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConBuy_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConBuy_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->status)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConBuy_result::~CTAOperation_SetFutureSpreadConBuy_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConBuy_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConBuy_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConBuy_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConBuy_presult::~CTAOperation_SetFutureSpreadConBuy_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConBuy_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadConSell_args::~CTAOperation_SetFutureSpreadConSell_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConSell_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConSell_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConSell_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConSell_pargs::~CTAOperation_SetFutureSpreadConSell_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConSell_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConSell_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->status)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConSell_result::~CTAOperation_SetFutureSpreadConSell_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConSell_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConSell_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConSell_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConSell_presult::~CTAOperation_SetFutureSpreadConSell_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConSell_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadFairSpread_args::~CTAOperation_SetFutureSpreadFairSpread_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFairSpread_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->fairspread);
          this->__isset.fairspread = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadFairSpread_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFairSpread_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fairspread", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->fairspread);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFairSpread_pargs::~CTAOperation_SetFutureSpreadFairSpread_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFairSpread_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFairSpread_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fairspread", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->fairspread)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFairSpread_result::~CTAOperation_SetFutureSpreadFairSpread_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFairSpread_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadFairSpread_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFairSpread_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFairSpread_presult::~CTAOperation_SetFutureSpreadFairSpread_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFairSpread_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadPosShift_args::~CTAOperation_SetFutureSpreadPosShift_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadPosShift_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->posShift);
          this->__isset.posShift = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadPosShift_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadPosShift_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("posShift", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->posShift);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadPosShift_pargs::~CTAOperation_SetFutureSpreadPosShift_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadPosShift_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadPosShift_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("posShift", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->posShift)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadPosShift_result::~CTAOperation_SetFutureSpreadPosShift_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadPosShift_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadPosShift_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadPosShift_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadPosShift_presult::~CTAOperation_SetFutureSpreadPosShift_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadPosShift_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadMinGainCon_args::~CTAOperation_SetFutureSpreadMinGainCon_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainCon_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->minGainCon);
          this->__isset.minGainCon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMinGainCon_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinGainCon_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minGainCon", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->minGainCon);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinGainCon_pargs::~CTAOperation_SetFutureSpreadMinGainCon_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainCon_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinGainCon_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minGainCon", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->minGainCon)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinGainCon_result::~CTAOperation_SetFutureSpreadMinGainCon_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainCon_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMinGainCon_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinGainCon_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinGainCon_presult::~CTAOperation_SetFutureSpreadMinGainCon_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainCon_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadMinGainHit_args::~CTAOperation_SetFutureSpreadMinGainHit_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainHit_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->minGainHit);
          this->__isset.minGainHit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMinGainHit_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinGainHit_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minGainHit", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->minGainHit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinGainHit_pargs::~CTAOperation_SetFutureSpreadMinGainHit_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainHit_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinGainHit_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minGainHit", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->minGainHit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinGainHit_result::~CTAOperation_SetFutureSpreadMinGainHit_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainHit_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMinGainHit_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinGainHit_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinGainHit_presult::~CTAOperation_SetFutureSpreadMinGainHit_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainHit_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadMinInterval_args::~CTAOperation_SetFutureSpreadMinInterval_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinInterval_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MinInterval);
          this->__isset.MinInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMinInterval_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinInterval_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinInterval", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->MinInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinInterval_pargs::~CTAOperation_SetFutureSpreadMinInterval_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinInterval_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinInterval_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinInterval", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->MinInterval)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinInterval_result::~CTAOperation_SetFutureSpreadMinInterval_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinInterval_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMinInterval_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinInterval_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinInterval_presult::~CTAOperation_SetFutureSpreadMinInterval_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinInterval_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadMaxWaitInterval_args::~CTAOperation_SetFutureSpreadMaxWaitInterval_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxWaitInterval_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MaxWaitInterval);
          this->__isset.MaxWaitInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMaxWaitInterval_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMaxWaitInterval_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxWaitInterval", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->MaxWaitInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMaxWaitInterval_pargs::~CTAOperation_SetFutureSpreadMaxWaitInterval_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxWaitInterval_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMaxWaitInterval_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxWaitInterval", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->MaxWaitInterval)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMaxWaitInterval_result::~CTAOperation_SetFutureSpreadMaxWaitInterval_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxWaitInterval_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMaxWaitInterval_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMaxWaitInterval_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMaxWaitInterval_presult::~CTAOperation_SetFutureSpreadMaxWaitInterval_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxWaitInterval_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadHitSize_args::~CTAOperation_SetFutureSpreadHitSize_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadHitSize_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->HitSize);
          this->__isset.HitSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadHitSize_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadHitSize_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("HitSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->HitSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadHitSize_pargs::~CTAOperation_SetFutureSpreadHitSize_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadHitSize_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadHitSize_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("HitSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->HitSize)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadHitSize_result::~CTAOperation_SetFutureSpreadHitSize_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadHitSize_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadHitSize_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadHitSize_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadHitSize_presult::~CTAOperation_SetFutureSpreadHitSize_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadHitSize_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadConSize_args::~CTAOperation_SetFutureSpreadConSize_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConSize_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ConSize);
          this->__isset.ConSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConSize_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConSize_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ConSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConSize_pargs::~CTAOperation_SetFutureSpreadConSize_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConSize_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConSize_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->ConSize)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConSize_result::~CTAOperation_SetFutureSpreadConSize_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConSize_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConSize_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConSize_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConSize_presult::~CTAOperation_SetFutureSpreadConSize_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConSize_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadConMinDiff_args::~CTAOperation_SetFutureSpreadConMinDiff_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConMinDiff_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ConMinDiff);
          this->__isset.ConMinDiff = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConMinDiff_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConMinDiff_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConMinDiff", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->ConMinDiff);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConMinDiff_pargs::~CTAOperation_SetFutureSpreadConMinDiff_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConMinDiff_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConMinDiff_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConMinDiff", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->ConMinDiff)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConMinDiff_result::~CTAOperation_SetFutureSpreadConMinDiff_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConMinDiff_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConMinDiff_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConMinDiff_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConMinDiff_presult::~CTAOperation_SetFutureSpreadConMinDiff_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConMinDiff_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadMinGainConExit_args::~CTAOperation_SetFutureSpreadMinGainConExit_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainConExit_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MinGainConExit);
          this->__isset.MinGainConExit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMinGainConExit_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinGainConExit_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinGainConExit", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->MinGainConExit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinGainConExit_pargs::~CTAOperation_SetFutureSpreadMinGainConExit_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainConExit_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinGainConExit_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinGainConExit", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->MinGainConExit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinGainConExit_result::~CTAOperation_SetFutureSpreadMinGainConExit_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainConExit_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMinGainConExit_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMinGainConExit_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMinGainConExit_presult::~CTAOperation_SetFutureSpreadMinGainConExit_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMinGainConExit_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadConMaxDistance_args::~CTAOperation_SetFutureSpreadConMaxDistance_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConMaxDistance_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ConMaxDistance);
          this->__isset.ConMaxDistance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConMaxDistance_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConMaxDistance_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConMaxDistance", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->ConMaxDistance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConMaxDistance_pargs::~CTAOperation_SetFutureSpreadConMaxDistance_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConMaxDistance_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConMaxDistance_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConMaxDistance", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->ConMaxDistance)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConMaxDistance_result::~CTAOperation_SetFutureSpreadConMaxDistance_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConMaxDistance_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConMaxDistance_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConMaxDistance_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConMaxDistance_presult::~CTAOperation_SetFutureSpreadConMaxDistance_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConMaxDistance_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadFuture1Pos_args::~CTAOperation_SetFutureSpreadFuture1Pos_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFuture1Pos_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Future1Pos);
          this->__isset.Future1Pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadFuture1Pos_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFuture1Pos_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Future1Pos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->Future1Pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFuture1Pos_pargs::~CTAOperation_SetFutureSpreadFuture1Pos_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFuture1Pos_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFuture1Pos_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Future1Pos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->Future1Pos)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFuture1Pos_result::~CTAOperation_SetFutureSpreadFuture1Pos_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFuture1Pos_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadFuture1Pos_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFuture1Pos_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFuture1Pos_presult::~CTAOperation_SetFutureSpreadFuture1Pos_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFuture1Pos_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadFuture2Pos_args::~CTAOperation_SetFutureSpreadFuture2Pos_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFuture2Pos_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Future2Pos);
          this->__isset.Future2Pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadFuture2Pos_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFuture2Pos_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Future2Pos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->Future2Pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFuture2Pos_pargs::~CTAOperation_SetFutureSpreadFuture2Pos_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFuture2Pos_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFuture2Pos_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Future2Pos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->Future2Pos)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFuture2Pos_result::~CTAOperation_SetFutureSpreadFuture2Pos_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFuture2Pos_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadFuture2Pos_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFuture2Pos_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFuture2Pos_presult::~CTAOperation_SetFutureSpreadFuture2Pos_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFuture2Pos_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadMaxNumOrders_args::~CTAOperation_SetFutureSpreadMaxNumOrders_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxNumOrders_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MaxNumOrders);
          this->__isset.MaxNumOrders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMaxNumOrders_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMaxNumOrders_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxNumOrders", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->MaxNumOrders);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMaxNumOrders_pargs::~CTAOperation_SetFutureSpreadMaxNumOrders_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxNumOrders_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMaxNumOrders_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxNumOrders", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->MaxNumOrders)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMaxNumOrders_result::~CTAOperation_SetFutureSpreadMaxNumOrders_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxNumOrders_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMaxNumOrders_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMaxNumOrders_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMaxNumOrders_presult::~CTAOperation_SetFutureSpreadMaxNumOrders_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxNumOrders_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadMaxPos_args::~CTAOperation_SetFutureSpreadMaxPos_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxPos_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->MaxPos);
          this->__isset.MaxPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMaxPos_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMaxPos_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->MaxPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMaxPos_pargs::~CTAOperation_SetFutureSpreadMaxPos_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxPos_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMaxPos_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->MaxPos)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMaxPos_result::~CTAOperation_SetFutureSpreadMaxPos_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxPos_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadMaxPos_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadMaxPos_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadMaxPos_presult::~CTAOperation_SetFutureSpreadMaxPos_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadMaxPos_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadUseMarketOrder_args::~CTAOperation_SetFutureSpreadUseMarketOrder_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadUseMarketOrder_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->useMarketORder);
          this->__isset.useMarketORder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadUseMarketOrder_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadUseMarketOrder_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("useMarketORder", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->useMarketORder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadUseMarketOrder_pargs::~CTAOperation_SetFutureSpreadUseMarketOrder_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadUseMarketOrder_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadUseMarketOrder_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("useMarketORder", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->useMarketORder)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadUseMarketOrder_result::~CTAOperation_SetFutureSpreadUseMarketOrder_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadUseMarketOrder_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadUseMarketOrder_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadUseMarketOrder_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadUseMarketOrder_presult::~CTAOperation_SetFutureSpreadUseMarketOrder_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadUseMarketOrder_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadPosConvex_args::~CTAOperation_SetFutureSpreadPosConvex_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadPosConvex_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->posConvex);
          this->__isset.posConvex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadPosConvex_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadPosConvex_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("posConvex", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->posConvex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadPosConvex_pargs::~CTAOperation_SetFutureSpreadPosConvex_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadPosConvex_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadPosConvex_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("posConvex", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->posConvex)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadPosConvex_result::~CTAOperation_SetFutureSpreadPosConvex_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadPosConvex_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadPosConvex_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadPosConvex_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadPosConvex_presult::~CTAOperation_SetFutureSpreadPosConvex_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadPosConvex_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadIgnoreUpDnLimit_args::~CTAOperation_SetFutureSpreadIgnoreUpDnLimit_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadIgnoreUpDnLimit_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->IgnoreUpDnLimit);
          this->__isset.IgnoreUpDnLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadIgnoreUpDnLimit_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadIgnoreUpDnLimit_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("IgnoreUpDnLimit", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->IgnoreUpDnLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadIgnoreUpDnLimit_pargs::~CTAOperation_SetFutureSpreadIgnoreUpDnLimit_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadIgnoreUpDnLimit_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadIgnoreUpDnLimit_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("IgnoreUpDnLimit", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->IgnoreUpDnLimit)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadIgnoreUpDnLimit_result::~CTAOperation_SetFutureSpreadIgnoreUpDnLimit_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadIgnoreUpDnLimit_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadIgnoreUpDnLimit_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadIgnoreUpDnLimit_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadIgnoreUpDnLimit_presult::~CTAOperation_SetFutureSpreadIgnoreUpDnLimit_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadIgnoreUpDnLimit_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadConvergeRate_args::~CTAOperation_SetFutureSpreadConvergeRate_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConvergeRate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ConvergeRate);
          this->__isset.ConvergeRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConvergeRate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConvergeRate_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConvergeRate", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->ConvergeRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConvergeRate_pargs::~CTAOperation_SetFutureSpreadConvergeRate_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConvergeRate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConvergeRate_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ConvergeRate", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->ConvergeRate)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConvergeRate_result::~CTAOperation_SetFutureSpreadConvergeRate_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConvergeRate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadConvergeRate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadConvergeRate_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadConvergeRate_presult::~CTAOperation_SetFutureSpreadConvergeRate_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadConvergeRate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadFastConvergeRate_args::~CTAOperation_SetFutureSpreadFastConvergeRate_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFastConvergeRate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->FastConvergeRate);
          this->__isset.FastConvergeRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadFastConvergeRate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFastConvergeRate_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("FastConvergeRate", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->FastConvergeRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFastConvergeRate_pargs::~CTAOperation_SetFutureSpreadFastConvergeRate_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFastConvergeRate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFastConvergeRate_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("FastConvergeRate", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->FastConvergeRate)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFastConvergeRate_result::~CTAOperation_SetFutureSpreadFastConvergeRate_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFastConvergeRate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadFastConvergeRate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadFastConvergeRate_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadFastConvergeRate_presult::~CTAOperation_SetFutureSpreadFastConvergeRate_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadFastConvergeRate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpreadRatio_args::~CTAOperation_SetFutureSpreadRatio_args() throw() {
}


uint32_t CTAOperation_SetFutureSpreadRatio_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Ratio);
          this->__isset.Ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadRatio_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadRatio_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Ratio", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Ratio);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadRatio_pargs::~CTAOperation_SetFutureSpreadRatio_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpreadRatio_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadRatio_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Ratio", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->Ratio)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadRatio_result::~CTAOperation_SetFutureSpreadRatio_result() throw() {
}


uint32_t CTAOperation_SetFutureSpreadRatio_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpreadRatio_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpreadRatio_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpreadRatio_presult::~CTAOperation_SetFutureSpreadRatio_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpreadRatio_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetAtsFutureSpreadFut1_args::~CTAOperation_SetAtsFutureSpreadFut1_args() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadFut1_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetAtsFutureSpreadFut1_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadFut1_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadFut1_pargs::~CTAOperation_SetAtsFutureSpreadFut1_pargs() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadFut1_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadFut1_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadFut1_result::~CTAOperation_SetAtsFutureSpreadFut1_result() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadFut1_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetAtsFutureSpreadFut1_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadFut1_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadFut1_presult::~CTAOperation_SetAtsFutureSpreadFut1_presult() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadFut1_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetAtsFutureSpreadFut2_args::~CTAOperation_SetAtsFutureSpreadFut2_args() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadFut2_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetAtsFutureSpreadFut2_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadFut2_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadFut2_pargs::~CTAOperation_SetAtsFutureSpreadFut2_pargs() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadFut2_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadFut2_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadFut2_result::~CTAOperation_SetAtsFutureSpreadFut2_result() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadFut2_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetAtsFutureSpreadFut2_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadFut2_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadFut2_presult::~CTAOperation_SetAtsFutureSpreadFut2_presult() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadFut2_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetAtsFutureSpreadLastKLineTime_args::~CTAOperation_SetAtsFutureSpreadLastKLineTime_args() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadLastKLineTime_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->KLineTime);
          this->__isset.KLineTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetAtsFutureSpreadLastKLineTime_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadLastKLineTime_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("KLineTime", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->KLineTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadLastKLineTime_pargs::~CTAOperation_SetAtsFutureSpreadLastKLineTime_pargs() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadLastKLineTime_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadLastKLineTime_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("KLineTime", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->KLineTime)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadLastKLineTime_result::~CTAOperation_SetAtsFutureSpreadLastKLineTime_result() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadLastKLineTime_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetAtsFutureSpreadLastKLineTime_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadLastKLineTime_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadLastKLineTime_presult::~CTAOperation_SetAtsFutureSpreadLastKLineTime_presult() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadLastKLineTime_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetAtsFutureSpreadKInterval_args::~CTAOperation_SetAtsFutureSpreadKInterval_args() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadKInterval_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->KInterval);
          this->__isset.KInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetAtsFutureSpreadKInterval_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadKInterval_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("KInterval", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->KInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadKInterval_pargs::~CTAOperation_SetAtsFutureSpreadKInterval_pargs() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadKInterval_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadKInterval_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("KInterval", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->KInterval)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadKInterval_result::~CTAOperation_SetAtsFutureSpreadKInterval_result() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadKInterval_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetAtsFutureSpreadKInterval_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetAtsFutureSpreadKInterval_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetAtsFutureSpreadKInterval_presult::~CTAOperation_SetAtsFutureSpreadKInterval_presult() throw() {
}


uint32_t CTAOperation_SetAtsFutureSpreadKInterval_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_CreateAutomaton_args::~CTAOperation_CreateAutomaton_args() throw() {
}


uint32_t CTAOperation_CreateAutomaton_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->automatonName);
          this->__isset.automatonName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->underlyingName);
          this->__isset.underlyingName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subscrib_list);
          this->__isset.subscrib_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->feedsourcesStr);
          this->__isset.feedsourcesStr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connectionsStr);
          this->__isset.connectionsStr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_CreateAutomaton_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_CreateAutomaton_args");

  xfer += oprot->writeFieldBegin("automatonName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->automatonName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("underlyingName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->underlyingName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("subscrib_list", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->subscrib_list);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("feedsourcesStr", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->feedsourcesStr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connectionsStr", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->connectionsStr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_CreateAutomaton_pargs::~CTAOperation_CreateAutomaton_pargs() throw() {
}


uint32_t CTAOperation_CreateAutomaton_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_CreateAutomaton_pargs");

  xfer += oprot->writeFieldBegin("automatonName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->automatonName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("underlyingName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->underlyingName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("subscrib_list", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->subscrib_list)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("feedsourcesStr", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->feedsourcesStr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connectionsStr", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->connectionsStr)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_CreateAutomaton_result::~CTAOperation_CreateAutomaton_result() throw() {
}


uint32_t CTAOperation_CreateAutomaton_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_CreateAutomaton_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_CreateAutomaton_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_CreateAutomaton_presult::~CTAOperation_CreateAutomaton_presult() throw() {
}


uint32_t CTAOperation_CreateAutomaton_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SpreadBidHitTrade_args::~CTAOperation_SpreadBidHitTrade_args() throw() {
}


uint32_t CTAOperation_SpreadBidHitTrade_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SpreadBidHitTrade_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SpreadBidHitTrade_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadBidHitTrade_pargs::~CTAOperation_SpreadBidHitTrade_pargs() throw() {
}


uint32_t CTAOperation_SpreadBidHitTrade_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SpreadBidHitTrade_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadBidHitTrade_result::~CTAOperation_SpreadBidHitTrade_result() throw() {
}


uint32_t CTAOperation_SpreadBidHitTrade_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SpreadBidHitTrade_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SpreadBidHitTrade_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadBidHitTrade_presult::~CTAOperation_SpreadBidHitTrade_presult() throw() {
}


uint32_t CTAOperation_SpreadBidHitTrade_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SpreadAskHitTrade_args::~CTAOperation_SpreadAskHitTrade_args() throw() {
}


uint32_t CTAOperation_SpreadAskHitTrade_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SpreadAskHitTrade_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SpreadAskHitTrade_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadAskHitTrade_pargs::~CTAOperation_SpreadAskHitTrade_pargs() throw() {
}


uint32_t CTAOperation_SpreadAskHitTrade_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SpreadAskHitTrade_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadAskHitTrade_result::~CTAOperation_SpreadAskHitTrade_result() throw() {
}


uint32_t CTAOperation_SpreadAskHitTrade_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SpreadAskHitTrade_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SpreadAskHitTrade_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadAskHitTrade_presult::~CTAOperation_SpreadAskHitTrade_presult() throw() {
}


uint32_t CTAOperation_SpreadAskHitTrade_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SpreadBidConTrade_args::~CTAOperation_SpreadBidConTrade_args() throw() {
}


uint32_t CTAOperation_SpreadBidConTrade_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SpreadBidConTrade_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SpreadBidConTrade_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadBidConTrade_pargs::~CTAOperation_SpreadBidConTrade_pargs() throw() {
}


uint32_t CTAOperation_SpreadBidConTrade_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SpreadBidConTrade_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadBidConTrade_result::~CTAOperation_SpreadBidConTrade_result() throw() {
}


uint32_t CTAOperation_SpreadBidConTrade_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SpreadBidConTrade_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SpreadBidConTrade_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadBidConTrade_presult::~CTAOperation_SpreadBidConTrade_presult() throw() {
}


uint32_t CTAOperation_SpreadBidConTrade_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SpreadAskConTrade_args::~CTAOperation_SpreadAskConTrade_args() throw() {
}


uint32_t CTAOperation_SpreadAskConTrade_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SpreadAskConTrade_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SpreadAskConTrade_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadAskConTrade_pargs::~CTAOperation_SpreadAskConTrade_pargs() throw() {
}


uint32_t CTAOperation_SpreadAskConTrade_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SpreadAskConTrade_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadAskConTrade_result::~CTAOperation_SpreadAskConTrade_result() throw() {
}


uint32_t CTAOperation_SpreadAskConTrade_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SpreadAskConTrade_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SpreadAskConTrade_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SpreadAskConTrade_presult::~CTAOperation_SpreadAskConTrade_presult() throw() {
}


uint32_t CTAOperation_SpreadAskConTrade_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetKeepOrders_args::~CTAOperation_SetKeepOrders_args() throw() {
}


uint32_t CTAOperation_SetKeepOrders_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->keepOrders);
          this->__isset.keepOrders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetKeepOrders_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetKeepOrders_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keepOrders", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->keepOrders);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetKeepOrders_pargs::~CTAOperation_SetKeepOrders_pargs() throw() {
}


uint32_t CTAOperation_SetKeepOrders_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetKeepOrders_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("keepOrders", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->keepOrders)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetKeepOrders_result::~CTAOperation_SetKeepOrders_result() throw() {
}


uint32_t CTAOperation_SetKeepOrders_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetKeepOrders_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetKeepOrders_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetKeepOrders_presult::~CTAOperation_SetKeepOrders_presult() throw() {
}


uint32_t CTAOperation_SetKeepOrders_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetForceOpen_args::~CTAOperation_SetForceOpen_args() throw() {
}


uint32_t CTAOperation_SetForceOpen_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->forceOpen);
          this->__isset.forceOpen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetForceOpen_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetForceOpen_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forceOpen", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->forceOpen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetForceOpen_pargs::~CTAOperation_SetForceOpen_pargs() throw() {
}


uint32_t CTAOperation_SetForceOpen_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetForceOpen_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forceOpen", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->forceOpen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetForceOpen_result::~CTAOperation_SetForceOpen_result() throw() {
}


uint32_t CTAOperation_SetForceOpen_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetForceOpen_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetForceOpen_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetForceOpen_presult::~CTAOperation_SetForceOpen_presult() throw() {
}


uint32_t CTAOperation_SetForceOpen_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpeedConvergeRate_args::~CTAOperation_SetFutureSpeedConvergeRate_args() throw() {
}


uint32_t CTAOperation_SetFutureSpeedConvergeRate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->SpeedConvergeRate);
          this->__isset.SpeedConvergeRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpeedConvergeRate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpeedConvergeRate_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("SpeedConvergeRate", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->SpeedConvergeRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpeedConvergeRate_pargs::~CTAOperation_SetFutureSpeedConvergeRate_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpeedConvergeRate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpeedConvergeRate_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("SpeedConvergeRate", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->SpeedConvergeRate)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpeedConvergeRate_result::~CTAOperation_SetFutureSpeedConvergeRate_result() throw() {
}


uint32_t CTAOperation_SetFutureSpeedConvergeRate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpeedConvergeRate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpeedConvergeRate_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpeedConvergeRate_presult::~CTAOperation_SetFutureSpeedConvergeRate_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpeedConvergeRate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureSpeed_args::~CTAOperation_SetFutureSpeed_args() throw() {
}


uint32_t CTAOperation_SetFutureSpeed_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Speed);
          this->__isset.Speed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpeed_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpeed_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Speed", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Speed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpeed_pargs::~CTAOperation_SetFutureSpeed_pargs() throw() {
}


uint32_t CTAOperation_SetFutureSpeed_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpeed_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Speed", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->Speed)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpeed_result::~CTAOperation_SetFutureSpeed_result() throw() {
}


uint32_t CTAOperation_SetFutureSpeed_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureSpeed_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureSpeed_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureSpeed_presult::~CTAOperation_SetFutureSpeed_presult() throw() {
}


uint32_t CTAOperation_SetFutureSpeed_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetFutureLastSpread_args::~CTAOperation_SetFutureLastSpread_args() throw() {
}


uint32_t CTAOperation_SetFutureLastSpread_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->LastSpread);
          this->__isset.LastSpread = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureLastSpread_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureLastSpread_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("LastSpread", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->LastSpread);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureLastSpread_pargs::~CTAOperation_SetFutureLastSpread_pargs() throw() {
}


uint32_t CTAOperation_SetFutureLastSpread_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetFutureLastSpread_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("LastSpread", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->LastSpread)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureLastSpread_result::~CTAOperation_SetFutureLastSpread_result() throw() {
}


uint32_t CTAOperation_SetFutureLastSpread_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetFutureLastSpread_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetFutureLastSpread_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetFutureLastSpread_presult::~CTAOperation_SetFutureLastSpread_presult() throw() {
}


uint32_t CTAOperation_SetFutureLastSpread_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetVolatility_args::~CTAOperation_SetVolatility_args() throw() {
}


uint32_t CTAOperation_SetVolatility_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Vol);
          this->__isset.Vol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetVolatility_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetVolatility_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Vol", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Vol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetVolatility_pargs::~CTAOperation_SetVolatility_pargs() throw() {
}


uint32_t CTAOperation_SetVolatility_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetVolatility_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Vol", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->Vol)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetVolatility_result::~CTAOperation_SetVolatility_result() throw() {
}


uint32_t CTAOperation_SetVolatility_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetVolatility_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetVolatility_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetVolatility_presult::~CTAOperation_SetVolatility_presult() throw() {
}


uint32_t CTAOperation_SetVolatility_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetMaxVolRange_args::~CTAOperation_SetMaxVolRange_args() throw() {
}


uint32_t CTAOperation_SetMaxVolRange_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MaxVolRange);
          this->__isset.MaxVolRange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetMaxVolRange_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetMaxVolRange_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxVolRange", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->MaxVolRange);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMaxVolRange_pargs::~CTAOperation_SetMaxVolRange_pargs() throw() {
}


uint32_t CTAOperation_SetMaxVolRange_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetMaxVolRange_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxVolRange", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->MaxVolRange)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMaxVolRange_result::~CTAOperation_SetMaxVolRange_result() throw() {
}


uint32_t CTAOperation_SetMaxVolRange_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetMaxVolRange_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetMaxVolRange_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMaxVolRange_presult::~CTAOperation_SetMaxVolRange_presult() throw() {
}


uint32_t CTAOperation_SetMaxVolRange_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetMarketMakerActive_args::~CTAOperation_SetMarketMakerActive_args() throw() {
}


uint32_t CTAOperation_SetMarketMakerActive_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->active);
          this->__isset.active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetMarketMakerActive_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerActive_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("active", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->active);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerActive_pargs::~CTAOperation_SetMarketMakerActive_pargs() throw() {
}


uint32_t CTAOperation_SetMarketMakerActive_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerActive_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("active", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->active)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerActive_result::~CTAOperation_SetMarketMakerActive_result() throw() {
}


uint32_t CTAOperation_SetMarketMakerActive_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetMarketMakerActive_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerActive_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerActive_presult::~CTAOperation_SetMarketMakerActive_presult() throw() {
}


uint32_t CTAOperation_SetMarketMakerActive_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetMarketMakerDouble_args::~CTAOperation_SetMarketMakerDouble_args() throw() {
}


uint32_t CTAOperation_SetMarketMakerDouble_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param);
          this->__isset.param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetMarketMakerDouble_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerDouble_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->param);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerDouble_pargs::~CTAOperation_SetMarketMakerDouble_pargs() throw() {
}


uint32_t CTAOperation_SetMarketMakerDouble_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerDouble_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->param)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerDouble_result::~CTAOperation_SetMarketMakerDouble_result() throw() {
}


uint32_t CTAOperation_SetMarketMakerDouble_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetMarketMakerDouble_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerDouble_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerDouble_presult::~CTAOperation_SetMarketMakerDouble_presult() throw() {
}


uint32_t CTAOperation_SetMarketMakerDouble_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetMarketMakerInt_args::~CTAOperation_SetMarketMakerInt_args() throw() {
}


uint32_t CTAOperation_SetMarketMakerInt_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param);
          this->__isset.param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetMarketMakerInt_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerInt_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->param);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerInt_pargs::~CTAOperation_SetMarketMakerInt_pargs() throw() {
}


uint32_t CTAOperation_SetMarketMakerInt_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerInt_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->param)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerInt_result::~CTAOperation_SetMarketMakerInt_result() throw() {
}


uint32_t CTAOperation_SetMarketMakerInt_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetMarketMakerInt_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerInt_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerInt_presult::~CTAOperation_SetMarketMakerInt_presult() throw() {
}


uint32_t CTAOperation_SetMarketMakerInt_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetDoFutureMarketMaker_args::~CTAOperation_SetDoFutureMarketMaker_args() throw() {
}


uint32_t CTAOperation_SetDoFutureMarketMaker_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetDoFutureMarketMaker_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetDoFutureMarketMaker_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetDoFutureMarketMaker_pargs::~CTAOperation_SetDoFutureMarketMaker_pargs() throw() {
}


uint32_t CTAOperation_SetDoFutureMarketMaker_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetDoFutureMarketMaker_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetDoFutureMarketMaker_result::~CTAOperation_SetDoFutureMarketMaker_result() throw() {
}


uint32_t CTAOperation_SetDoFutureMarketMaker_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetDoFutureMarketMaker_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetDoFutureMarketMaker_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetDoFutureMarketMaker_presult::~CTAOperation_SetDoFutureMarketMaker_presult() throw() {
}


uint32_t CTAOperation_SetDoFutureMarketMaker_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetMarketMakerCanReduce_args::~CTAOperation_SetMarketMakerCanReduce_args() throw() {
}


uint32_t CTAOperation_SetMarketMakerCanReduce_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetMarketMakerCanReduce_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerCanReduce_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerCanReduce_pargs::~CTAOperation_SetMarketMakerCanReduce_pargs() throw() {
}


uint32_t CTAOperation_SetMarketMakerCanReduce_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerCanReduce_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->value)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerCanReduce_result::~CTAOperation_SetMarketMakerCanReduce_result() throw() {
}


uint32_t CTAOperation_SetMarketMakerCanReduce_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetMarketMakerCanReduce_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetMarketMakerCanReduce_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetMarketMakerCanReduce_presult::~CTAOperation_SetMarketMakerCanReduce_presult() throw() {
}


uint32_t CTAOperation_SetMarketMakerCanReduce_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_ForceContribe_args::~CTAOperation_ForceContribe_args() throw() {
}


uint32_t CTAOperation_ForceContribe_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_ForceContribe_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_ForceContribe_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_ForceContribe_pargs::~CTAOperation_ForceContribe_pargs() throw() {
}


uint32_t CTAOperation_ForceContribe_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_ForceContribe_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_ForceContribe_result::~CTAOperation_ForceContribe_result() throw() {
}


uint32_t CTAOperation_ForceContribe_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_ForceContribe_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_ForceContribe_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_ForceContribe_presult::~CTAOperation_ForceContribe_presult() throw() {
}


uint32_t CTAOperation_ForceContribe_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_ResetMovingAvg_args::~CTAOperation_ResetMovingAvg_args() throw() {
}


uint32_t CTAOperation_ResetMovingAvg_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_ResetMovingAvg_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_ResetMovingAvg_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_ResetMovingAvg_pargs::~CTAOperation_ResetMovingAvg_pargs() throw() {
}


uint32_t CTAOperation_ResetMovingAvg_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_ResetMovingAvg_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_ResetMovingAvg_result::~CTAOperation_ResetMovingAvg_result() throw() {
}


uint32_t CTAOperation_ResetMovingAvg_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_ResetMovingAvg_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_ResetMovingAvg_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_ResetMovingAvg_presult::~CTAOperation_ResetMovingAvg_presult() throw() {
}


uint32_t CTAOperation_ResetMovingAvg_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetTwapData_args::~CTAOperation_SetTwapData_args() throw() {
}


uint32_t CTAOperation_SetTwapData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetTwapData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetTwapData_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetTwapData_pargs::~CTAOperation_SetTwapData_pargs() throw() {
}


uint32_t CTAOperation_SetTwapData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetTwapData_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->data)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetTwapData_result::~CTAOperation_SetTwapData_result() throw() {
}


uint32_t CTAOperation_SetTwapData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetTwapData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetTwapData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetTwapData_presult::~CTAOperation_SetTwapData_presult() throw() {
}


uint32_t CTAOperation_SetTwapData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetTurtleAlgoData_args::~CTAOperation_SetTurtleAlgoData_args() throw() {
}


uint32_t CTAOperation_SetTurtleAlgoData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetTurtleAlgoData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetTurtleAlgoData_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetTurtleAlgoData_pargs::~CTAOperation_SetTurtleAlgoData_pargs() throw() {
}


uint32_t CTAOperation_SetTurtleAlgoData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetTurtleAlgoData_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->data)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetTurtleAlgoData_result::~CTAOperation_SetTurtleAlgoData_result() throw() {
}


uint32_t CTAOperation_SetTurtleAlgoData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetTurtleAlgoData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetTurtleAlgoData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetTurtleAlgoData_presult::~CTAOperation_SetTurtleAlgoData_presult() throw() {
}


uint32_t CTAOperation_SetTurtleAlgoData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetKlineConfig_args::~CTAOperation_SetKlineConfig_args() throw() {
}


uint32_t CTAOperation_SetKlineConfig_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetKlineConfig_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetKlineConfig_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetKlineConfig_pargs::~CTAOperation_SetKlineConfig_pargs() throw() {
}


uint32_t CTAOperation_SetKlineConfig_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetKlineConfig_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->data)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetKlineConfig_result::~CTAOperation_SetKlineConfig_result() throw() {
}


uint32_t CTAOperation_SetKlineConfig_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetKlineConfig_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetKlineConfig_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetKlineConfig_presult::~CTAOperation_SetKlineConfig_presult() throw() {
}


uint32_t CTAOperation_SetKlineConfig_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetTurtleFuture_args::~CTAOperation_SetTurtleFuture_args() throw() {
}


uint32_t CTAOperation_SetTurtleFuture_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetTurtleFuture_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetTurtleFuture_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetTurtleFuture_pargs::~CTAOperation_SetTurtleFuture_pargs() throw() {
}


uint32_t CTAOperation_SetTurtleFuture_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetTurtleFuture_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->code)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetTurtleFuture_result::~CTAOperation_SetTurtleFuture_result() throw() {
}


uint32_t CTAOperation_SetTurtleFuture_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetTurtleFuture_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetTurtleFuture_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeString(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetTurtleFuture_presult::~CTAOperation_SetTurtleFuture_presult() throw() {
}


uint32_t CTAOperation_SetTurtleFuture_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_SetRiskDegree_args::~CTAOperation_SetRiskDegree_args() throw() {
}


uint32_t CTAOperation_SetRiskDegree_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->atsName);
          this->__isset.atsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->RiskDegree);
          this->__isset.RiskDegree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetRiskDegree_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetRiskDegree_args");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->atsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("RiskDegree", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->RiskDegree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetRiskDegree_pargs::~CTAOperation_SetRiskDegree_pargs() throw() {
}


uint32_t CTAOperation_SetRiskDegree_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_SetRiskDegree_pargs");

  xfer += oprot->writeFieldBegin("atsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->atsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("RiskDegree", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble((*(this->RiskDegree)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetRiskDegree_result::~CTAOperation_SetRiskDegree_result() throw() {
}


uint32_t CTAOperation_SetRiskDegree_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_SetRiskDegree_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_SetRiskDegree_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_DOUBLE, 0);
    xfer += oprot->writeDouble(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_SetRiskDegree_presult::~CTAOperation_SetRiskDegree_presult() throw() {
}


uint32_t CTAOperation_SetRiskDegree_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


CTAOperation_MatchOrders_args::~CTAOperation_MatchOrders_args() throw() {
}


uint32_t CTAOperation_MatchOrders_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_MatchOrders_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_MatchOrders_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_MatchOrders_pargs::~CTAOperation_MatchOrders_pargs() throw() {
}


uint32_t CTAOperation_MatchOrders_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CTAOperation_MatchOrders_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_MatchOrders_result::~CTAOperation_MatchOrders_result() throw() {
}


uint32_t CTAOperation_MatchOrders_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CTAOperation_MatchOrders_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("CTAOperation_MatchOrders_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


CTAOperation_MatchOrders_presult::~CTAOperation_MatchOrders_presult() throw() {
}


uint32_t CTAOperation_MatchOrders_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

bool CTAOperationClient::SetFutureSpreadHitStatus(const std::string& atsName, const bool status)
{
  send_SetFutureSpreadHitStatus(atsName, status);
  return recv_SetFutureSpreadHitStatus();
}

void CTAOperationClient::send_SetFutureSpreadHitStatus(const std::string& atsName, const bool status)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadHitStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadHitStatus_pargs args;
  args.atsName = &atsName;
  args.status = &status;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetFutureSpreadHitStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadHitStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetFutureSpreadHitStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadHitStatus failed: unknown result");
}

bool CTAOperationClient::SetFutureSpreadConStatus(const std::string& atsName, const bool status)
{
  send_SetFutureSpreadConStatus(atsName, status);
  return recv_SetFutureSpreadConStatus();
}

void CTAOperationClient::send_SetFutureSpreadConStatus(const std::string& atsName, const bool status)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadConStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConStatus_pargs args;
  args.atsName = &atsName;
  args.status = &status;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetFutureSpreadConStatus()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadConStatus") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetFutureSpreadConStatus_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConStatus failed: unknown result");
}

bool CTAOperationClient::SetFutureSpreadConBuy(const std::string& atsName, const bool status)
{
  send_SetFutureSpreadConBuy(atsName, status);
  return recv_SetFutureSpreadConBuy();
}

void CTAOperationClient::send_SetFutureSpreadConBuy(const std::string& atsName, const bool status)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadConBuy", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConBuy_pargs args;
  args.atsName = &atsName;
  args.status = &status;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetFutureSpreadConBuy()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadConBuy") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetFutureSpreadConBuy_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConBuy failed: unknown result");
}

bool CTAOperationClient::SetFutureSpreadConSell(const std::string& atsName, const bool status)
{
  send_SetFutureSpreadConSell(atsName, status);
  return recv_SetFutureSpreadConSell();
}

void CTAOperationClient::send_SetFutureSpreadConSell(const std::string& atsName, const bool status)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadConSell", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConSell_pargs args;
  args.atsName = &atsName;
  args.status = &status;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetFutureSpreadConSell()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadConSell") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetFutureSpreadConSell_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConSell failed: unknown result");
}

double CTAOperationClient::SetFutureSpreadFairSpread(const std::string& atsName, const double fairspread)
{
  send_SetFutureSpreadFairSpread(atsName, fairspread);
  return recv_SetFutureSpreadFairSpread();
}

void CTAOperationClient::send_SetFutureSpreadFairSpread(const std::string& atsName, const double fairspread)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadFairSpread", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadFairSpread_pargs args;
  args.atsName = &atsName;
  args.fairspread = &fairspread;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpreadFairSpread()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadFairSpread") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpreadFairSpread_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadFairSpread failed: unknown result");
}

double CTAOperationClient::SetFutureSpreadPosShift(const std::string& atsName, const double posShift)
{
  send_SetFutureSpreadPosShift(atsName, posShift);
  return recv_SetFutureSpreadPosShift();
}

void CTAOperationClient::send_SetFutureSpreadPosShift(const std::string& atsName, const double posShift)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadPosShift", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadPosShift_pargs args;
  args.atsName = &atsName;
  args.posShift = &posShift;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpreadPosShift()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadPosShift") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpreadPosShift_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadPosShift failed: unknown result");
}

double CTAOperationClient::SetFutureSpreadMinGainCon(const std::string& atsName, const double minGainCon)
{
  send_SetFutureSpreadMinGainCon(atsName, minGainCon);
  return recv_SetFutureSpreadMinGainCon();
}

void CTAOperationClient::send_SetFutureSpreadMinGainCon(const std::string& atsName, const double minGainCon)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadMinGainCon", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMinGainCon_pargs args;
  args.atsName = &atsName;
  args.minGainCon = &minGainCon;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpreadMinGainCon()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadMinGainCon") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpreadMinGainCon_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMinGainCon failed: unknown result");
}

double CTAOperationClient::SetFutureSpreadMinGainHit(const std::string& atsName, const double minGainHit)
{
  send_SetFutureSpreadMinGainHit(atsName, minGainHit);
  return recv_SetFutureSpreadMinGainHit();
}

void CTAOperationClient::send_SetFutureSpreadMinGainHit(const std::string& atsName, const double minGainHit)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadMinGainHit", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMinGainHit_pargs args;
  args.atsName = &atsName;
  args.minGainHit = &minGainHit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpreadMinGainHit()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadMinGainHit") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpreadMinGainHit_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMinGainHit failed: unknown result");
}

int32_t CTAOperationClient::SetFutureSpreadMinInterval(const std::string& atsName, const int32_t MinInterval)
{
  send_SetFutureSpreadMinInterval(atsName, MinInterval);
  return recv_SetFutureSpreadMinInterval();
}

void CTAOperationClient::send_SetFutureSpreadMinInterval(const std::string& atsName, const int32_t MinInterval)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadMinInterval", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMinInterval_pargs args;
  args.atsName = &atsName;
  args.MinInterval = &MinInterval;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t CTAOperationClient::recv_SetFutureSpreadMinInterval()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadMinInterval") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  CTAOperation_SetFutureSpreadMinInterval_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMinInterval failed: unknown result");
}

int32_t CTAOperationClient::SetFutureSpreadMaxWaitInterval(const std::string& atsName, const int32_t MaxWaitInterval)
{
  send_SetFutureSpreadMaxWaitInterval(atsName, MaxWaitInterval);
  return recv_SetFutureSpreadMaxWaitInterval();
}

void CTAOperationClient::send_SetFutureSpreadMaxWaitInterval(const std::string& atsName, const int32_t MaxWaitInterval)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadMaxWaitInterval", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMaxWaitInterval_pargs args;
  args.atsName = &atsName;
  args.MaxWaitInterval = &MaxWaitInterval;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t CTAOperationClient::recv_SetFutureSpreadMaxWaitInterval()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadMaxWaitInterval") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  CTAOperation_SetFutureSpreadMaxWaitInterval_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMaxWaitInterval failed: unknown result");
}

int32_t CTAOperationClient::SetFutureSpreadHitSize(const std::string& atsName, const int32_t HitSize)
{
  send_SetFutureSpreadHitSize(atsName, HitSize);
  return recv_SetFutureSpreadHitSize();
}

void CTAOperationClient::send_SetFutureSpreadHitSize(const std::string& atsName, const int32_t HitSize)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadHitSize", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadHitSize_pargs args;
  args.atsName = &atsName;
  args.HitSize = &HitSize;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t CTAOperationClient::recv_SetFutureSpreadHitSize()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadHitSize") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  CTAOperation_SetFutureSpreadHitSize_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadHitSize failed: unknown result");
}

int32_t CTAOperationClient::SetFutureSpreadConSize(const std::string& atsName, const int32_t ConSize)
{
  send_SetFutureSpreadConSize(atsName, ConSize);
  return recv_SetFutureSpreadConSize();
}

void CTAOperationClient::send_SetFutureSpreadConSize(const std::string& atsName, const int32_t ConSize)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadConSize", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConSize_pargs args;
  args.atsName = &atsName;
  args.ConSize = &ConSize;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t CTAOperationClient::recv_SetFutureSpreadConSize()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadConSize") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  CTAOperation_SetFutureSpreadConSize_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConSize failed: unknown result");
}

double CTAOperationClient::SetFutureSpreadConMinDiff(const std::string& atsName, const double ConMinDiff)
{
  send_SetFutureSpreadConMinDiff(atsName, ConMinDiff);
  return recv_SetFutureSpreadConMinDiff();
}

void CTAOperationClient::send_SetFutureSpreadConMinDiff(const std::string& atsName, const double ConMinDiff)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadConMinDiff", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConMinDiff_pargs args;
  args.atsName = &atsName;
  args.ConMinDiff = &ConMinDiff;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpreadConMinDiff()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadConMinDiff") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpreadConMinDiff_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConMinDiff failed: unknown result");
}

double CTAOperationClient::SetFutureSpreadMinGainConExit(const std::string& atsName, const double MinGainConExit)
{
  send_SetFutureSpreadMinGainConExit(atsName, MinGainConExit);
  return recv_SetFutureSpreadMinGainConExit();
}

void CTAOperationClient::send_SetFutureSpreadMinGainConExit(const std::string& atsName, const double MinGainConExit)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadMinGainConExit", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMinGainConExit_pargs args;
  args.atsName = &atsName;
  args.MinGainConExit = &MinGainConExit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpreadMinGainConExit()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadMinGainConExit") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpreadMinGainConExit_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMinGainConExit failed: unknown result");
}

double CTAOperationClient::SetFutureSpreadConMaxDistance(const std::string& atsName, const double ConMaxDistance)
{
  send_SetFutureSpreadConMaxDistance(atsName, ConMaxDistance);
  return recv_SetFutureSpreadConMaxDistance();
}

void CTAOperationClient::send_SetFutureSpreadConMaxDistance(const std::string& atsName, const double ConMaxDistance)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadConMaxDistance", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConMaxDistance_pargs args;
  args.atsName = &atsName;
  args.ConMaxDistance = &ConMaxDistance;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpreadConMaxDistance()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadConMaxDistance") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpreadConMaxDistance_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConMaxDistance failed: unknown result");
}

int32_t CTAOperationClient::SetFutureSpreadFuture1Pos(const std::string& atsName, const int32_t Future1Pos)
{
  send_SetFutureSpreadFuture1Pos(atsName, Future1Pos);
  return recv_SetFutureSpreadFuture1Pos();
}

void CTAOperationClient::send_SetFutureSpreadFuture1Pos(const std::string& atsName, const int32_t Future1Pos)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadFuture1Pos", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadFuture1Pos_pargs args;
  args.atsName = &atsName;
  args.Future1Pos = &Future1Pos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t CTAOperationClient::recv_SetFutureSpreadFuture1Pos()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadFuture1Pos") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  CTAOperation_SetFutureSpreadFuture1Pos_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadFuture1Pos failed: unknown result");
}

int32_t CTAOperationClient::SetFutureSpreadFuture2Pos(const std::string& atsName, const int32_t Future2Pos)
{
  send_SetFutureSpreadFuture2Pos(atsName, Future2Pos);
  return recv_SetFutureSpreadFuture2Pos();
}

void CTAOperationClient::send_SetFutureSpreadFuture2Pos(const std::string& atsName, const int32_t Future2Pos)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadFuture2Pos", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadFuture2Pos_pargs args;
  args.atsName = &atsName;
  args.Future2Pos = &Future2Pos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t CTAOperationClient::recv_SetFutureSpreadFuture2Pos()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadFuture2Pos") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  CTAOperation_SetFutureSpreadFuture2Pos_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadFuture2Pos failed: unknown result");
}

int32_t CTAOperationClient::SetFutureSpreadMaxNumOrders(const std::string& atsName, const int32_t MaxNumOrders)
{
  send_SetFutureSpreadMaxNumOrders(atsName, MaxNumOrders);
  return recv_SetFutureSpreadMaxNumOrders();
}

void CTAOperationClient::send_SetFutureSpreadMaxNumOrders(const std::string& atsName, const int32_t MaxNumOrders)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadMaxNumOrders", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMaxNumOrders_pargs args;
  args.atsName = &atsName;
  args.MaxNumOrders = &MaxNumOrders;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t CTAOperationClient::recv_SetFutureSpreadMaxNumOrders()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadMaxNumOrders") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  CTAOperation_SetFutureSpreadMaxNumOrders_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMaxNumOrders failed: unknown result");
}

int32_t CTAOperationClient::SetFutureSpreadMaxPos(const std::string& atsName, const int32_t MaxPos)
{
  send_SetFutureSpreadMaxPos(atsName, MaxPos);
  return recv_SetFutureSpreadMaxPos();
}

void CTAOperationClient::send_SetFutureSpreadMaxPos(const std::string& atsName, const int32_t MaxPos)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadMaxPos", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMaxPos_pargs args;
  args.atsName = &atsName;
  args.MaxPos = &MaxPos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t CTAOperationClient::recv_SetFutureSpreadMaxPos()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadMaxPos") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  CTAOperation_SetFutureSpreadMaxPos_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMaxPos failed: unknown result");
}

bool CTAOperationClient::SetFutureSpreadUseMarketOrder(const std::string& atsName, const bool useMarketORder)
{
  send_SetFutureSpreadUseMarketOrder(atsName, useMarketORder);
  return recv_SetFutureSpreadUseMarketOrder();
}

void CTAOperationClient::send_SetFutureSpreadUseMarketOrder(const std::string& atsName, const bool useMarketORder)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadUseMarketOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadUseMarketOrder_pargs args;
  args.atsName = &atsName;
  args.useMarketORder = &useMarketORder;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetFutureSpreadUseMarketOrder()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadUseMarketOrder") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetFutureSpreadUseMarketOrder_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadUseMarketOrder failed: unknown result");
}

double CTAOperationClient::SetFutureSpreadPosConvex(const std::string& atsName, const double posConvex)
{
  send_SetFutureSpreadPosConvex(atsName, posConvex);
  return recv_SetFutureSpreadPosConvex();
}

void CTAOperationClient::send_SetFutureSpreadPosConvex(const std::string& atsName, const double posConvex)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadPosConvex", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadPosConvex_pargs args;
  args.atsName = &atsName;
  args.posConvex = &posConvex;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpreadPosConvex()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadPosConvex") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpreadPosConvex_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadPosConvex failed: unknown result");
}

bool CTAOperationClient::SetFutureSpreadIgnoreUpDnLimit(const std::string& atsName, const bool IgnoreUpDnLimit)
{
  send_SetFutureSpreadIgnoreUpDnLimit(atsName, IgnoreUpDnLimit);
  return recv_SetFutureSpreadIgnoreUpDnLimit();
}

void CTAOperationClient::send_SetFutureSpreadIgnoreUpDnLimit(const std::string& atsName, const bool IgnoreUpDnLimit)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadIgnoreUpDnLimit", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadIgnoreUpDnLimit_pargs args;
  args.atsName = &atsName;
  args.IgnoreUpDnLimit = &IgnoreUpDnLimit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetFutureSpreadIgnoreUpDnLimit()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadIgnoreUpDnLimit") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetFutureSpreadIgnoreUpDnLimit_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadIgnoreUpDnLimit failed: unknown result");
}

double CTAOperationClient::SetFutureSpreadConvergeRate(const std::string& atsName, const double ConvergeRate)
{
  send_SetFutureSpreadConvergeRate(atsName, ConvergeRate);
  return recv_SetFutureSpreadConvergeRate();
}

void CTAOperationClient::send_SetFutureSpreadConvergeRate(const std::string& atsName, const double ConvergeRate)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadConvergeRate", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConvergeRate_pargs args;
  args.atsName = &atsName;
  args.ConvergeRate = &ConvergeRate;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpreadConvergeRate()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadConvergeRate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpreadConvergeRate_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConvergeRate failed: unknown result");
}

double CTAOperationClient::SetFutureSpreadFastConvergeRate(const std::string& atsName, const double FastConvergeRate)
{
  send_SetFutureSpreadFastConvergeRate(atsName, FastConvergeRate);
  return recv_SetFutureSpreadFastConvergeRate();
}

void CTAOperationClient::send_SetFutureSpreadFastConvergeRate(const std::string& atsName, const double FastConvergeRate)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadFastConvergeRate", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadFastConvergeRate_pargs args;
  args.atsName = &atsName;
  args.FastConvergeRate = &FastConvergeRate;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpreadFastConvergeRate()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadFastConvergeRate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpreadFastConvergeRate_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadFastConvergeRate failed: unknown result");
}

double CTAOperationClient::SetFutureSpreadRatio(const std::string& atsName, const double Ratio)
{
  send_SetFutureSpreadRatio(atsName, Ratio);
  return recv_SetFutureSpreadRatio();
}

void CTAOperationClient::send_SetFutureSpreadRatio(const std::string& atsName, const double Ratio)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpreadRatio", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadRatio_pargs args;
  args.atsName = &atsName;
  args.Ratio = &Ratio;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpreadRatio()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpreadRatio") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpreadRatio_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadRatio failed: unknown result");
}

void CTAOperationClient::SetAtsFutureSpreadFut1(std::string& _return, const std::string& atsName, const std::string& code)
{
  send_SetAtsFutureSpreadFut1(atsName, code);
  recv_SetAtsFutureSpreadFut1(_return);
}

void CTAOperationClient::send_SetAtsFutureSpreadFut1(const std::string& atsName, const std::string& code)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetAtsFutureSpreadFut1", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetAtsFutureSpreadFut1_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_SetAtsFutureSpreadFut1(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetAtsFutureSpreadFut1") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_SetAtsFutureSpreadFut1_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetAtsFutureSpreadFut1 failed: unknown result");
}

void CTAOperationClient::SetAtsFutureSpreadFut2(std::string& _return, const std::string& atsName, const std::string& code)
{
  send_SetAtsFutureSpreadFut2(atsName, code);
  recv_SetAtsFutureSpreadFut2(_return);
}

void CTAOperationClient::send_SetAtsFutureSpreadFut2(const std::string& atsName, const std::string& code)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetAtsFutureSpreadFut2", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetAtsFutureSpreadFut2_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_SetAtsFutureSpreadFut2(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetAtsFutureSpreadFut2") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_SetAtsFutureSpreadFut2_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetAtsFutureSpreadFut2 failed: unknown result");
}

void CTAOperationClient::SetAtsFutureSpreadLastKLineTime(std::string& _return, const std::string& atsName, const std::string& KLineTime)
{
  send_SetAtsFutureSpreadLastKLineTime(atsName, KLineTime);
  recv_SetAtsFutureSpreadLastKLineTime(_return);
}

void CTAOperationClient::send_SetAtsFutureSpreadLastKLineTime(const std::string& atsName, const std::string& KLineTime)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetAtsFutureSpreadLastKLineTime", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetAtsFutureSpreadLastKLineTime_pargs args;
  args.atsName = &atsName;
  args.KLineTime = &KLineTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_SetAtsFutureSpreadLastKLineTime(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetAtsFutureSpreadLastKLineTime") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_SetAtsFutureSpreadLastKLineTime_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetAtsFutureSpreadLastKLineTime failed: unknown result");
}

void CTAOperationClient::SetAtsFutureSpreadKInterval(std::string& _return, const std::string& atsName, const std::string& KInterval)
{
  send_SetAtsFutureSpreadKInterval(atsName, KInterval);
  recv_SetAtsFutureSpreadKInterval(_return);
}

void CTAOperationClient::send_SetAtsFutureSpreadKInterval(const std::string& atsName, const std::string& KInterval)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetAtsFutureSpreadKInterval", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetAtsFutureSpreadKInterval_pargs args;
  args.atsName = &atsName;
  args.KInterval = &KInterval;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_SetAtsFutureSpreadKInterval(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetAtsFutureSpreadKInterval") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_SetAtsFutureSpreadKInterval_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetAtsFutureSpreadKInterval failed: unknown result");
}

void CTAOperationClient::CreateAutomaton(CTAAtsMsg& _return, const std::string& automatonName, const std::string& underlyingName, const std::string& subscrib_list, const std::string& feedsourcesStr, const std::string& connectionsStr)
{
  send_CreateAutomaton(automatonName, underlyingName, subscrib_list, feedsourcesStr, connectionsStr);
  recv_CreateAutomaton(_return);
}

void CTAOperationClient::send_CreateAutomaton(const std::string& automatonName, const std::string& underlyingName, const std::string& subscrib_list, const std::string& feedsourcesStr, const std::string& connectionsStr)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CreateAutomaton", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_CreateAutomaton_pargs args;
  args.automatonName = &automatonName;
  args.underlyingName = &underlyingName;
  args.subscrib_list = &subscrib_list;
  args.feedsourcesStr = &feedsourcesStr;
  args.connectionsStr = &connectionsStr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_CreateAutomaton(CTAAtsMsg& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("CreateAutomaton") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_CreateAutomaton_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CreateAutomaton failed: unknown result");
}

void CTAOperationClient::SpreadBidHitTrade(const std::string& atsName)
{
  send_SpreadBidHitTrade(atsName);
  recv_SpreadBidHitTrade();
}

void CTAOperationClient::send_SpreadBidHitTrade(const std::string& atsName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SpreadBidHitTrade", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SpreadBidHitTrade_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_SpreadBidHitTrade()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SpreadBidHitTrade") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_SpreadBidHitTrade_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void CTAOperationClient::SpreadAskHitTrade(const std::string& atsName)
{
  send_SpreadAskHitTrade(atsName);
  recv_SpreadAskHitTrade();
}

void CTAOperationClient::send_SpreadAskHitTrade(const std::string& atsName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SpreadAskHitTrade", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SpreadAskHitTrade_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_SpreadAskHitTrade()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SpreadAskHitTrade") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_SpreadAskHitTrade_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void CTAOperationClient::SpreadBidConTrade(const std::string& atsName)
{
  send_SpreadBidConTrade(atsName);
  recv_SpreadBidConTrade();
}

void CTAOperationClient::send_SpreadBidConTrade(const std::string& atsName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SpreadBidConTrade", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SpreadBidConTrade_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_SpreadBidConTrade()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SpreadBidConTrade") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_SpreadBidConTrade_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void CTAOperationClient::SpreadAskConTrade(const std::string& atsName)
{
  send_SpreadAskConTrade(atsName);
  recv_SpreadAskConTrade();
}

void CTAOperationClient::send_SpreadAskConTrade(const std::string& atsName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SpreadAskConTrade", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SpreadAskConTrade_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_SpreadAskConTrade()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SpreadAskConTrade") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_SpreadAskConTrade_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

bool CTAOperationClient::SetKeepOrders(const std::string& atsName, const bool keepOrders)
{
  send_SetKeepOrders(atsName, keepOrders);
  return recv_SetKeepOrders();
}

void CTAOperationClient::send_SetKeepOrders(const std::string& atsName, const bool keepOrders)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetKeepOrders", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetKeepOrders_pargs args;
  args.atsName = &atsName;
  args.keepOrders = &keepOrders;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetKeepOrders()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetKeepOrders") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetKeepOrders_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetKeepOrders failed: unknown result");
}

bool CTAOperationClient::SetForceOpen(const std::string& atsName, const bool forceOpen)
{
  send_SetForceOpen(atsName, forceOpen);
  return recv_SetForceOpen();
}

void CTAOperationClient::send_SetForceOpen(const std::string& atsName, const bool forceOpen)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetForceOpen", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetForceOpen_pargs args;
  args.atsName = &atsName;
  args.forceOpen = &forceOpen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetForceOpen()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetForceOpen") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetForceOpen_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetForceOpen failed: unknown result");
}

double CTAOperationClient::SetFutureSpeedConvergeRate(const std::string& atsName, const double SpeedConvergeRate)
{
  send_SetFutureSpeedConvergeRate(atsName, SpeedConvergeRate);
  return recv_SetFutureSpeedConvergeRate();
}

void CTAOperationClient::send_SetFutureSpeedConvergeRate(const std::string& atsName, const double SpeedConvergeRate)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpeedConvergeRate", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpeedConvergeRate_pargs args;
  args.atsName = &atsName;
  args.SpeedConvergeRate = &SpeedConvergeRate;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpeedConvergeRate()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpeedConvergeRate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpeedConvergeRate_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpeedConvergeRate failed: unknown result");
}

double CTAOperationClient::SetFutureSpeed(const std::string& atsName, const double Speed)
{
  send_SetFutureSpeed(atsName, Speed);
  return recv_SetFutureSpeed();
}

void CTAOperationClient::send_SetFutureSpeed(const std::string& atsName, const double Speed)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureSpeed", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpeed_pargs args;
  args.atsName = &atsName;
  args.Speed = &Speed;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureSpeed()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureSpeed") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureSpeed_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpeed failed: unknown result");
}

double CTAOperationClient::SetFutureLastSpread(const std::string& atsName, const double LastSpread)
{
  send_SetFutureLastSpread(atsName, LastSpread);
  return recv_SetFutureLastSpread();
}

void CTAOperationClient::send_SetFutureLastSpread(const std::string& atsName, const double LastSpread)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetFutureLastSpread", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureLastSpread_pargs args;
  args.atsName = &atsName;
  args.LastSpread = &LastSpread;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetFutureLastSpread()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetFutureLastSpread") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetFutureLastSpread_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureLastSpread failed: unknown result");
}

double CTAOperationClient::SetVolatility(const std::string& atsName, const double Vol)
{
  send_SetVolatility(atsName, Vol);
  return recv_SetVolatility();
}

void CTAOperationClient::send_SetVolatility(const std::string& atsName, const double Vol)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetVolatility", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetVolatility_pargs args;
  args.atsName = &atsName;
  args.Vol = &Vol;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetVolatility()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetVolatility") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetVolatility_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetVolatility failed: unknown result");
}

double CTAOperationClient::SetMaxVolRange(const std::string& atsName, const double MaxVolRange)
{
  send_SetMaxVolRange(atsName, MaxVolRange);
  return recv_SetMaxVolRange();
}

void CTAOperationClient::send_SetMaxVolRange(const std::string& atsName, const double MaxVolRange)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetMaxVolRange", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetMaxVolRange_pargs args;
  args.atsName = &atsName;
  args.MaxVolRange = &MaxVolRange;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetMaxVolRange()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetMaxVolRange") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetMaxVolRange_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetMaxVolRange failed: unknown result");
}

bool CTAOperationClient::SetMarketMakerActive(const std::string& atsName, const std::string& code, const bool active)
{
  send_SetMarketMakerActive(atsName, code, active);
  return recv_SetMarketMakerActive();
}

void CTAOperationClient::send_SetMarketMakerActive(const std::string& atsName, const std::string& code, const bool active)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetMarketMakerActive", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetMarketMakerActive_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.active = &active;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetMarketMakerActive()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetMarketMakerActive") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetMarketMakerActive_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetMarketMakerActive failed: unknown result");
}

double CTAOperationClient::SetMarketMakerDouble(const std::string& atsName, const std::string& code, const std::string& param, const double value)
{
  send_SetMarketMakerDouble(atsName, code, param, value);
  return recv_SetMarketMakerDouble();
}

void CTAOperationClient::send_SetMarketMakerDouble(const std::string& atsName, const std::string& code, const std::string& param, const double value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetMarketMakerDouble", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetMarketMakerDouble_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.param = &param;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetMarketMakerDouble()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetMarketMakerDouble") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetMarketMakerDouble_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetMarketMakerDouble failed: unknown result");
}

int32_t CTAOperationClient::SetMarketMakerInt(const std::string& atsName, const std::string& code, const std::string& param, const int32_t value)
{
  send_SetMarketMakerInt(atsName, code, param, value);
  return recv_SetMarketMakerInt();
}

void CTAOperationClient::send_SetMarketMakerInt(const std::string& atsName, const std::string& code, const std::string& param, const int32_t value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetMarketMakerInt", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetMarketMakerInt_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.param = &param;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t CTAOperationClient::recv_SetMarketMakerInt()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetMarketMakerInt") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  CTAOperation_SetMarketMakerInt_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetMarketMakerInt failed: unknown result");
}

bool CTAOperationClient::SetDoFutureMarketMaker(const std::string& atsName, const bool value)
{
  send_SetDoFutureMarketMaker(atsName, value);
  return recv_SetDoFutureMarketMaker();
}

void CTAOperationClient::send_SetDoFutureMarketMaker(const std::string& atsName, const bool value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetDoFutureMarketMaker", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetDoFutureMarketMaker_pargs args;
  args.atsName = &atsName;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetDoFutureMarketMaker()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetDoFutureMarketMaker") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetDoFutureMarketMaker_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetDoFutureMarketMaker failed: unknown result");
}

bool CTAOperationClient::SetMarketMakerCanReduce(const std::string& atsName, const bool value)
{
  send_SetMarketMakerCanReduce(atsName, value);
  return recv_SetMarketMakerCanReduce();
}

void CTAOperationClient::send_SetMarketMakerCanReduce(const std::string& atsName, const bool value)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetMarketMakerCanReduce", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetMarketMakerCanReduce_pargs args;
  args.atsName = &atsName;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetMarketMakerCanReduce()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetMarketMakerCanReduce") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetMarketMakerCanReduce_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetMarketMakerCanReduce failed: unknown result");
}

void CTAOperationClient::ForceContribe(const std::string& atsName)
{
  send_ForceContribe(atsName);
  recv_ForceContribe();
}

void CTAOperationClient::send_ForceContribe(const std::string& atsName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ForceContribe", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_ForceContribe_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_ForceContribe()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("ForceContribe") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_ForceContribe_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void CTAOperationClient::ResetMovingAvg(const std::string& atsName)
{
  send_ResetMovingAvg(atsName);
  recv_ResetMovingAvg();
}

void CTAOperationClient::send_ResetMovingAvg(const std::string& atsName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ResetMovingAvg", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_ResetMovingAvg_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_ResetMovingAvg()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("ResetMovingAvg") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_ResetMovingAvg_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

bool CTAOperationClient::SetTwapData(const std::string& atsName, const TWAPDataMsg& data)
{
  send_SetTwapData(atsName, data);
  return recv_SetTwapData();
}

void CTAOperationClient::send_SetTwapData(const std::string& atsName, const TWAPDataMsg& data)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetTwapData", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetTwapData_pargs args;
  args.atsName = &atsName;
  args.data = &data;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetTwapData()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetTwapData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetTwapData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetTwapData failed: unknown result");
}

bool CTAOperationClient::SetTurtleAlgoData(const std::string& atsName, const TurtleAlgoMsg& data)
{
  send_SetTurtleAlgoData(atsName, data);
  return recv_SetTurtleAlgoData();
}

void CTAOperationClient::send_SetTurtleAlgoData(const std::string& atsName, const TurtleAlgoMsg& data)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetTurtleAlgoData", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetTurtleAlgoData_pargs args;
  args.atsName = &atsName;
  args.data = &data;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetTurtleAlgoData()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetTurtleAlgoData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetTurtleAlgoData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetTurtleAlgoData failed: unknown result");
}

bool CTAOperationClient::SetKlineConfig(const std::string& atsName, const KlineConfigMsg& data)
{
  send_SetKlineConfig(atsName, data);
  return recv_SetKlineConfig();
}

void CTAOperationClient::send_SetKlineConfig(const std::string& atsName, const KlineConfigMsg& data)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetKlineConfig", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetKlineConfig_pargs args;
  args.atsName = &atsName;
  args.data = &data;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool CTAOperationClient::recv_SetKlineConfig()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetKlineConfig") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  CTAOperation_SetKlineConfig_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetKlineConfig failed: unknown result");
}

void CTAOperationClient::SetTurtleFuture(std::string& _return, const std::string& atsName, const std::string& code)
{
  send_SetTurtleFuture(atsName, code);
  recv_SetTurtleFuture(_return);
}

void CTAOperationClient::send_SetTurtleFuture(const std::string& atsName, const std::string& code)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetTurtleFuture", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetTurtleFuture_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_SetTurtleFuture(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetTurtleFuture") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_SetTurtleFuture_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetTurtleFuture failed: unknown result");
}

double CTAOperationClient::SetRiskDegree(const std::string& atsName, const double RiskDegree)
{
  send_SetRiskDegree(atsName, RiskDegree);
  return recv_SetRiskDegree();
}

void CTAOperationClient::send_SetRiskDegree(const std::string& atsName, const double RiskDegree)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetRiskDegree", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetRiskDegree_pargs args;
  args.atsName = &atsName;
  args.RiskDegree = &RiskDegree;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

double CTAOperationClient::recv_SetRiskDegree()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetRiskDegree") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  double _return;
  CTAOperation_SetRiskDegree_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetRiskDegree failed: unknown result");
}

void CTAOperationClient::MatchOrders()
{
  send_MatchOrders();
  recv_MatchOrders();
}

void CTAOperationClient::send_MatchOrders()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("MatchOrders", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_MatchOrders_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void CTAOperationClient::recv_MatchOrders()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("MatchOrders") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  CTAOperation_MatchOrders_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

bool CTAOperationProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return  ::AtsGeneral::AtsOperationProcessor::dispatchCall(iprot, oprot, fname, seqid, callContext);
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void CTAOperationProcessor::process_SetFutureSpreadHitStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadHitStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadHitStatus");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadHitStatus");
  }

  CTAOperation_SetFutureSpreadHitStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadHitStatus", bytes);
  }

  CTAOperation_SetFutureSpreadHitStatus_result result;
  try {
    result.success = iface_->SetFutureSpreadHitStatus(args.atsName, args.status);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadHitStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadHitStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadHitStatus");
  }

  oprot->writeMessageBegin("SetFutureSpreadHitStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadHitStatus", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadConStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadConStatus", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadConStatus");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadConStatus");
  }

  CTAOperation_SetFutureSpreadConStatus_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadConStatus", bytes);
  }

  CTAOperation_SetFutureSpreadConStatus_result result;
  try {
    result.success = iface_->SetFutureSpreadConStatus(args.atsName, args.status);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadConStatus");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadConStatus", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadConStatus");
  }

  oprot->writeMessageBegin("SetFutureSpreadConStatus", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadConStatus", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadConBuy(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadConBuy", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadConBuy");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadConBuy");
  }

  CTAOperation_SetFutureSpreadConBuy_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadConBuy", bytes);
  }

  CTAOperation_SetFutureSpreadConBuy_result result;
  try {
    result.success = iface_->SetFutureSpreadConBuy(args.atsName, args.status);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadConBuy");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadConBuy", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadConBuy");
  }

  oprot->writeMessageBegin("SetFutureSpreadConBuy", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadConBuy", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadConSell(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadConSell", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadConSell");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadConSell");
  }

  CTAOperation_SetFutureSpreadConSell_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadConSell", bytes);
  }

  CTAOperation_SetFutureSpreadConSell_result result;
  try {
    result.success = iface_->SetFutureSpreadConSell(args.atsName, args.status);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadConSell");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadConSell", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadConSell");
  }

  oprot->writeMessageBegin("SetFutureSpreadConSell", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadConSell", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadFairSpread(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadFairSpread", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadFairSpread");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadFairSpread");
  }

  CTAOperation_SetFutureSpreadFairSpread_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadFairSpread", bytes);
  }

  CTAOperation_SetFutureSpreadFairSpread_result result;
  try {
    result.success = iface_->SetFutureSpreadFairSpread(args.atsName, args.fairspread);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadFairSpread");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadFairSpread", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadFairSpread");
  }

  oprot->writeMessageBegin("SetFutureSpreadFairSpread", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadFairSpread", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadPosShift(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadPosShift", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadPosShift");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadPosShift");
  }

  CTAOperation_SetFutureSpreadPosShift_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadPosShift", bytes);
  }

  CTAOperation_SetFutureSpreadPosShift_result result;
  try {
    result.success = iface_->SetFutureSpreadPosShift(args.atsName, args.posShift);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadPosShift");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadPosShift", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadPosShift");
  }

  oprot->writeMessageBegin("SetFutureSpreadPosShift", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadPosShift", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadMinGainCon(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadMinGainCon", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadMinGainCon");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadMinGainCon");
  }

  CTAOperation_SetFutureSpreadMinGainCon_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadMinGainCon", bytes);
  }

  CTAOperation_SetFutureSpreadMinGainCon_result result;
  try {
    result.success = iface_->SetFutureSpreadMinGainCon(args.atsName, args.minGainCon);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadMinGainCon");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadMinGainCon", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadMinGainCon");
  }

  oprot->writeMessageBegin("SetFutureSpreadMinGainCon", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadMinGainCon", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadMinGainHit(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadMinGainHit", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadMinGainHit");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadMinGainHit");
  }

  CTAOperation_SetFutureSpreadMinGainHit_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadMinGainHit", bytes);
  }

  CTAOperation_SetFutureSpreadMinGainHit_result result;
  try {
    result.success = iface_->SetFutureSpreadMinGainHit(args.atsName, args.minGainHit);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadMinGainHit");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadMinGainHit", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadMinGainHit");
  }

  oprot->writeMessageBegin("SetFutureSpreadMinGainHit", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadMinGainHit", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadMinInterval(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadMinInterval", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadMinInterval");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadMinInterval");
  }

  CTAOperation_SetFutureSpreadMinInterval_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadMinInterval", bytes);
  }

  CTAOperation_SetFutureSpreadMinInterval_result result;
  try {
    result.success = iface_->SetFutureSpreadMinInterval(args.atsName, args.MinInterval);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadMinInterval");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadMinInterval", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadMinInterval");
  }

  oprot->writeMessageBegin("SetFutureSpreadMinInterval", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadMinInterval", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadMaxWaitInterval(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadMaxWaitInterval", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadMaxWaitInterval");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadMaxWaitInterval");
  }

  CTAOperation_SetFutureSpreadMaxWaitInterval_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadMaxWaitInterval", bytes);
  }

  CTAOperation_SetFutureSpreadMaxWaitInterval_result result;
  try {
    result.success = iface_->SetFutureSpreadMaxWaitInterval(args.atsName, args.MaxWaitInterval);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadMaxWaitInterval");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadMaxWaitInterval", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadMaxWaitInterval");
  }

  oprot->writeMessageBegin("SetFutureSpreadMaxWaitInterval", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadMaxWaitInterval", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadHitSize(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadHitSize", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadHitSize");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadHitSize");
  }

  CTAOperation_SetFutureSpreadHitSize_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadHitSize", bytes);
  }

  CTAOperation_SetFutureSpreadHitSize_result result;
  try {
    result.success = iface_->SetFutureSpreadHitSize(args.atsName, args.HitSize);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadHitSize");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadHitSize", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadHitSize");
  }

  oprot->writeMessageBegin("SetFutureSpreadHitSize", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadHitSize", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadConSize(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadConSize", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadConSize");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadConSize");
  }

  CTAOperation_SetFutureSpreadConSize_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadConSize", bytes);
  }

  CTAOperation_SetFutureSpreadConSize_result result;
  try {
    result.success = iface_->SetFutureSpreadConSize(args.atsName, args.ConSize);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadConSize");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadConSize", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadConSize");
  }

  oprot->writeMessageBegin("SetFutureSpreadConSize", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadConSize", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadConMinDiff(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadConMinDiff", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadConMinDiff");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadConMinDiff");
  }

  CTAOperation_SetFutureSpreadConMinDiff_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadConMinDiff", bytes);
  }

  CTAOperation_SetFutureSpreadConMinDiff_result result;
  try {
    result.success = iface_->SetFutureSpreadConMinDiff(args.atsName, args.ConMinDiff);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadConMinDiff");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadConMinDiff", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadConMinDiff");
  }

  oprot->writeMessageBegin("SetFutureSpreadConMinDiff", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadConMinDiff", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadMinGainConExit(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadMinGainConExit", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadMinGainConExit");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadMinGainConExit");
  }

  CTAOperation_SetFutureSpreadMinGainConExit_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadMinGainConExit", bytes);
  }

  CTAOperation_SetFutureSpreadMinGainConExit_result result;
  try {
    result.success = iface_->SetFutureSpreadMinGainConExit(args.atsName, args.MinGainConExit);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadMinGainConExit");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadMinGainConExit", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadMinGainConExit");
  }

  oprot->writeMessageBegin("SetFutureSpreadMinGainConExit", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadMinGainConExit", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadConMaxDistance(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadConMaxDistance", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadConMaxDistance");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadConMaxDistance");
  }

  CTAOperation_SetFutureSpreadConMaxDistance_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadConMaxDistance", bytes);
  }

  CTAOperation_SetFutureSpreadConMaxDistance_result result;
  try {
    result.success = iface_->SetFutureSpreadConMaxDistance(args.atsName, args.ConMaxDistance);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadConMaxDistance");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadConMaxDistance", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadConMaxDistance");
  }

  oprot->writeMessageBegin("SetFutureSpreadConMaxDistance", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadConMaxDistance", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadFuture1Pos(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadFuture1Pos", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadFuture1Pos");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadFuture1Pos");
  }

  CTAOperation_SetFutureSpreadFuture1Pos_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadFuture1Pos", bytes);
  }

  CTAOperation_SetFutureSpreadFuture1Pos_result result;
  try {
    result.success = iface_->SetFutureSpreadFuture1Pos(args.atsName, args.Future1Pos);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadFuture1Pos");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadFuture1Pos", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadFuture1Pos");
  }

  oprot->writeMessageBegin("SetFutureSpreadFuture1Pos", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadFuture1Pos", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadFuture2Pos(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadFuture2Pos", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadFuture2Pos");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadFuture2Pos");
  }

  CTAOperation_SetFutureSpreadFuture2Pos_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadFuture2Pos", bytes);
  }

  CTAOperation_SetFutureSpreadFuture2Pos_result result;
  try {
    result.success = iface_->SetFutureSpreadFuture2Pos(args.atsName, args.Future2Pos);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadFuture2Pos");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadFuture2Pos", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadFuture2Pos");
  }

  oprot->writeMessageBegin("SetFutureSpreadFuture2Pos", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadFuture2Pos", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadMaxNumOrders(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadMaxNumOrders", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadMaxNumOrders");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadMaxNumOrders");
  }

  CTAOperation_SetFutureSpreadMaxNumOrders_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadMaxNumOrders", bytes);
  }

  CTAOperation_SetFutureSpreadMaxNumOrders_result result;
  try {
    result.success = iface_->SetFutureSpreadMaxNumOrders(args.atsName, args.MaxNumOrders);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadMaxNumOrders");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadMaxNumOrders", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadMaxNumOrders");
  }

  oprot->writeMessageBegin("SetFutureSpreadMaxNumOrders", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadMaxNumOrders", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadMaxPos(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadMaxPos", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadMaxPos");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadMaxPos");
  }

  CTAOperation_SetFutureSpreadMaxPos_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadMaxPos", bytes);
  }

  CTAOperation_SetFutureSpreadMaxPos_result result;
  try {
    result.success = iface_->SetFutureSpreadMaxPos(args.atsName, args.MaxPos);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadMaxPos");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadMaxPos", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadMaxPos");
  }

  oprot->writeMessageBegin("SetFutureSpreadMaxPos", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadMaxPos", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadUseMarketOrder(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadUseMarketOrder", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadUseMarketOrder");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadUseMarketOrder");
  }

  CTAOperation_SetFutureSpreadUseMarketOrder_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadUseMarketOrder", bytes);
  }

  CTAOperation_SetFutureSpreadUseMarketOrder_result result;
  try {
    result.success = iface_->SetFutureSpreadUseMarketOrder(args.atsName, args.useMarketORder);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadUseMarketOrder");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadUseMarketOrder", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadUseMarketOrder");
  }

  oprot->writeMessageBegin("SetFutureSpreadUseMarketOrder", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadUseMarketOrder", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadPosConvex(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadPosConvex", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadPosConvex");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadPosConvex");
  }

  CTAOperation_SetFutureSpreadPosConvex_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadPosConvex", bytes);
  }

  CTAOperation_SetFutureSpreadPosConvex_result result;
  try {
    result.success = iface_->SetFutureSpreadPosConvex(args.atsName, args.posConvex);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadPosConvex");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadPosConvex", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadPosConvex");
  }

  oprot->writeMessageBegin("SetFutureSpreadPosConvex", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadPosConvex", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadIgnoreUpDnLimit(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadIgnoreUpDnLimit", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadIgnoreUpDnLimit");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadIgnoreUpDnLimit");
  }

  CTAOperation_SetFutureSpreadIgnoreUpDnLimit_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadIgnoreUpDnLimit", bytes);
  }

  CTAOperation_SetFutureSpreadIgnoreUpDnLimit_result result;
  try {
    result.success = iface_->SetFutureSpreadIgnoreUpDnLimit(args.atsName, args.IgnoreUpDnLimit);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadIgnoreUpDnLimit");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadIgnoreUpDnLimit", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadIgnoreUpDnLimit");
  }

  oprot->writeMessageBegin("SetFutureSpreadIgnoreUpDnLimit", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadIgnoreUpDnLimit", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadConvergeRate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadConvergeRate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadConvergeRate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadConvergeRate");
  }

  CTAOperation_SetFutureSpreadConvergeRate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadConvergeRate", bytes);
  }

  CTAOperation_SetFutureSpreadConvergeRate_result result;
  try {
    result.success = iface_->SetFutureSpreadConvergeRate(args.atsName, args.ConvergeRate);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadConvergeRate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadConvergeRate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadConvergeRate");
  }

  oprot->writeMessageBegin("SetFutureSpreadConvergeRate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadConvergeRate", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadFastConvergeRate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadFastConvergeRate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadFastConvergeRate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadFastConvergeRate");
  }

  CTAOperation_SetFutureSpreadFastConvergeRate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadFastConvergeRate", bytes);
  }

  CTAOperation_SetFutureSpreadFastConvergeRate_result result;
  try {
    result.success = iface_->SetFutureSpreadFastConvergeRate(args.atsName, args.FastConvergeRate);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadFastConvergeRate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadFastConvergeRate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadFastConvergeRate");
  }

  oprot->writeMessageBegin("SetFutureSpreadFastConvergeRate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadFastConvergeRate", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpreadRatio(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpreadRatio", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpreadRatio");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpreadRatio");
  }

  CTAOperation_SetFutureSpreadRatio_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpreadRatio", bytes);
  }

  CTAOperation_SetFutureSpreadRatio_result result;
  try {
    result.success = iface_->SetFutureSpreadRatio(args.atsName, args.Ratio);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpreadRatio");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpreadRatio", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpreadRatio");
  }

  oprot->writeMessageBegin("SetFutureSpreadRatio", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpreadRatio", bytes);
  }
}

void CTAOperationProcessor::process_SetAtsFutureSpreadFut1(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetAtsFutureSpreadFut1", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetAtsFutureSpreadFut1");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetAtsFutureSpreadFut1");
  }

  CTAOperation_SetAtsFutureSpreadFut1_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetAtsFutureSpreadFut1", bytes);
  }

  CTAOperation_SetAtsFutureSpreadFut1_result result;
  try {
    iface_->SetAtsFutureSpreadFut1(result.success, args.atsName, args.code);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetAtsFutureSpreadFut1");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetAtsFutureSpreadFut1", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetAtsFutureSpreadFut1");
  }

  oprot->writeMessageBegin("SetAtsFutureSpreadFut1", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetAtsFutureSpreadFut1", bytes);
  }
}

void CTAOperationProcessor::process_SetAtsFutureSpreadFut2(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetAtsFutureSpreadFut2", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetAtsFutureSpreadFut2");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetAtsFutureSpreadFut2");
  }

  CTAOperation_SetAtsFutureSpreadFut2_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetAtsFutureSpreadFut2", bytes);
  }

  CTAOperation_SetAtsFutureSpreadFut2_result result;
  try {
    iface_->SetAtsFutureSpreadFut2(result.success, args.atsName, args.code);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetAtsFutureSpreadFut2");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetAtsFutureSpreadFut2", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetAtsFutureSpreadFut2");
  }

  oprot->writeMessageBegin("SetAtsFutureSpreadFut2", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetAtsFutureSpreadFut2", bytes);
  }
}

void CTAOperationProcessor::process_SetAtsFutureSpreadLastKLineTime(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetAtsFutureSpreadLastKLineTime", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetAtsFutureSpreadLastKLineTime");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetAtsFutureSpreadLastKLineTime");
  }

  CTAOperation_SetAtsFutureSpreadLastKLineTime_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetAtsFutureSpreadLastKLineTime", bytes);
  }

  CTAOperation_SetAtsFutureSpreadLastKLineTime_result result;
  try {
    iface_->SetAtsFutureSpreadLastKLineTime(result.success, args.atsName, args.KLineTime);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetAtsFutureSpreadLastKLineTime");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetAtsFutureSpreadLastKLineTime", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetAtsFutureSpreadLastKLineTime");
  }

  oprot->writeMessageBegin("SetAtsFutureSpreadLastKLineTime", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetAtsFutureSpreadLastKLineTime", bytes);
  }
}

void CTAOperationProcessor::process_SetAtsFutureSpreadKInterval(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetAtsFutureSpreadKInterval", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetAtsFutureSpreadKInterval");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetAtsFutureSpreadKInterval");
  }

  CTAOperation_SetAtsFutureSpreadKInterval_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetAtsFutureSpreadKInterval", bytes);
  }

  CTAOperation_SetAtsFutureSpreadKInterval_result result;
  try {
    iface_->SetAtsFutureSpreadKInterval(result.success, args.atsName, args.KInterval);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetAtsFutureSpreadKInterval");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetAtsFutureSpreadKInterval", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetAtsFutureSpreadKInterval");
  }

  oprot->writeMessageBegin("SetAtsFutureSpreadKInterval", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetAtsFutureSpreadKInterval", bytes);
  }
}

void CTAOperationProcessor::process_CreateAutomaton(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.CreateAutomaton", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.CreateAutomaton");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.CreateAutomaton");
  }

  CTAOperation_CreateAutomaton_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.CreateAutomaton", bytes);
  }

  CTAOperation_CreateAutomaton_result result;
  try {
    iface_->CreateAutomaton(result.success, args.automatonName, args.underlyingName, args.subscrib_list, args.feedsourcesStr, args.connectionsStr);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.CreateAutomaton");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("CreateAutomaton", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.CreateAutomaton");
  }

  oprot->writeMessageBegin("CreateAutomaton", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.CreateAutomaton", bytes);
  }
}

void CTAOperationProcessor::process_SpreadBidHitTrade(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SpreadBidHitTrade", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SpreadBidHitTrade");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SpreadBidHitTrade");
  }

  CTAOperation_SpreadBidHitTrade_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SpreadBidHitTrade", bytes);
  }

  CTAOperation_SpreadBidHitTrade_result result;
  try {
    iface_->SpreadBidHitTrade(args.atsName);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SpreadBidHitTrade");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SpreadBidHitTrade", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SpreadBidHitTrade");
  }

  oprot->writeMessageBegin("SpreadBidHitTrade", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SpreadBidHitTrade", bytes);
  }
}

void CTAOperationProcessor::process_SpreadAskHitTrade(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SpreadAskHitTrade", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SpreadAskHitTrade");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SpreadAskHitTrade");
  }

  CTAOperation_SpreadAskHitTrade_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SpreadAskHitTrade", bytes);
  }

  CTAOperation_SpreadAskHitTrade_result result;
  try {
    iface_->SpreadAskHitTrade(args.atsName);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SpreadAskHitTrade");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SpreadAskHitTrade", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SpreadAskHitTrade");
  }

  oprot->writeMessageBegin("SpreadAskHitTrade", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SpreadAskHitTrade", bytes);
  }
}

void CTAOperationProcessor::process_SpreadBidConTrade(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SpreadBidConTrade", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SpreadBidConTrade");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SpreadBidConTrade");
  }

  CTAOperation_SpreadBidConTrade_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SpreadBidConTrade", bytes);
  }

  CTAOperation_SpreadBidConTrade_result result;
  try {
    iface_->SpreadBidConTrade(args.atsName);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SpreadBidConTrade");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SpreadBidConTrade", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SpreadBidConTrade");
  }

  oprot->writeMessageBegin("SpreadBidConTrade", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SpreadBidConTrade", bytes);
  }
}

void CTAOperationProcessor::process_SpreadAskConTrade(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SpreadAskConTrade", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SpreadAskConTrade");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SpreadAskConTrade");
  }

  CTAOperation_SpreadAskConTrade_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SpreadAskConTrade", bytes);
  }

  CTAOperation_SpreadAskConTrade_result result;
  try {
    iface_->SpreadAskConTrade(args.atsName);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SpreadAskConTrade");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SpreadAskConTrade", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SpreadAskConTrade");
  }

  oprot->writeMessageBegin("SpreadAskConTrade", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SpreadAskConTrade", bytes);
  }
}

void CTAOperationProcessor::process_SetKeepOrders(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetKeepOrders", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetKeepOrders");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetKeepOrders");
  }

  CTAOperation_SetKeepOrders_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetKeepOrders", bytes);
  }

  CTAOperation_SetKeepOrders_result result;
  try {
    result.success = iface_->SetKeepOrders(args.atsName, args.keepOrders);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetKeepOrders");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetKeepOrders", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetKeepOrders");
  }

  oprot->writeMessageBegin("SetKeepOrders", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetKeepOrders", bytes);
  }
}

void CTAOperationProcessor::process_SetForceOpen(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetForceOpen", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetForceOpen");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetForceOpen");
  }

  CTAOperation_SetForceOpen_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetForceOpen", bytes);
  }

  CTAOperation_SetForceOpen_result result;
  try {
    result.success = iface_->SetForceOpen(args.atsName, args.forceOpen);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetForceOpen");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetForceOpen", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetForceOpen");
  }

  oprot->writeMessageBegin("SetForceOpen", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetForceOpen", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpeedConvergeRate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpeedConvergeRate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpeedConvergeRate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpeedConvergeRate");
  }

  CTAOperation_SetFutureSpeedConvergeRate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpeedConvergeRate", bytes);
  }

  CTAOperation_SetFutureSpeedConvergeRate_result result;
  try {
    result.success = iface_->SetFutureSpeedConvergeRate(args.atsName, args.SpeedConvergeRate);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpeedConvergeRate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpeedConvergeRate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpeedConvergeRate");
  }

  oprot->writeMessageBegin("SetFutureSpeedConvergeRate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpeedConvergeRate", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureSpeed(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureSpeed", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureSpeed");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureSpeed");
  }

  CTAOperation_SetFutureSpeed_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureSpeed", bytes);
  }

  CTAOperation_SetFutureSpeed_result result;
  try {
    result.success = iface_->SetFutureSpeed(args.atsName, args.Speed);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureSpeed");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureSpeed", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureSpeed");
  }

  oprot->writeMessageBegin("SetFutureSpeed", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureSpeed", bytes);
  }
}

void CTAOperationProcessor::process_SetFutureLastSpread(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetFutureLastSpread", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetFutureLastSpread");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetFutureLastSpread");
  }

  CTAOperation_SetFutureLastSpread_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetFutureLastSpread", bytes);
  }

  CTAOperation_SetFutureLastSpread_result result;
  try {
    result.success = iface_->SetFutureLastSpread(args.atsName, args.LastSpread);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetFutureLastSpread");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetFutureLastSpread", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetFutureLastSpread");
  }

  oprot->writeMessageBegin("SetFutureLastSpread", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetFutureLastSpread", bytes);
  }
}

void CTAOperationProcessor::process_SetVolatility(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetVolatility", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetVolatility");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetVolatility");
  }

  CTAOperation_SetVolatility_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetVolatility", bytes);
  }

  CTAOperation_SetVolatility_result result;
  try {
    result.success = iface_->SetVolatility(args.atsName, args.Vol);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetVolatility");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetVolatility", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetVolatility");
  }

  oprot->writeMessageBegin("SetVolatility", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetVolatility", bytes);
  }
}

void CTAOperationProcessor::process_SetMaxVolRange(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetMaxVolRange", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetMaxVolRange");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetMaxVolRange");
  }

  CTAOperation_SetMaxVolRange_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetMaxVolRange", bytes);
  }

  CTAOperation_SetMaxVolRange_result result;
  try {
    result.success = iface_->SetMaxVolRange(args.atsName, args.MaxVolRange);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetMaxVolRange");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetMaxVolRange", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetMaxVolRange");
  }

  oprot->writeMessageBegin("SetMaxVolRange", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetMaxVolRange", bytes);
  }
}

void CTAOperationProcessor::process_SetMarketMakerActive(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetMarketMakerActive", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetMarketMakerActive");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetMarketMakerActive");
  }

  CTAOperation_SetMarketMakerActive_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetMarketMakerActive", bytes);
  }

  CTAOperation_SetMarketMakerActive_result result;
  try {
    result.success = iface_->SetMarketMakerActive(args.atsName, args.code, args.active);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetMarketMakerActive");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetMarketMakerActive", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetMarketMakerActive");
  }

  oprot->writeMessageBegin("SetMarketMakerActive", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetMarketMakerActive", bytes);
  }
}

void CTAOperationProcessor::process_SetMarketMakerDouble(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetMarketMakerDouble", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetMarketMakerDouble");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetMarketMakerDouble");
  }

  CTAOperation_SetMarketMakerDouble_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetMarketMakerDouble", bytes);
  }

  CTAOperation_SetMarketMakerDouble_result result;
  try {
    result.success = iface_->SetMarketMakerDouble(args.atsName, args.code, args.param, args.value);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetMarketMakerDouble");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetMarketMakerDouble", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetMarketMakerDouble");
  }

  oprot->writeMessageBegin("SetMarketMakerDouble", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetMarketMakerDouble", bytes);
  }
}

void CTAOperationProcessor::process_SetMarketMakerInt(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetMarketMakerInt", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetMarketMakerInt");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetMarketMakerInt");
  }

  CTAOperation_SetMarketMakerInt_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetMarketMakerInt", bytes);
  }

  CTAOperation_SetMarketMakerInt_result result;
  try {
    result.success = iface_->SetMarketMakerInt(args.atsName, args.code, args.param, args.value);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetMarketMakerInt");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetMarketMakerInt", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetMarketMakerInt");
  }

  oprot->writeMessageBegin("SetMarketMakerInt", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetMarketMakerInt", bytes);
  }
}

void CTAOperationProcessor::process_SetDoFutureMarketMaker(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetDoFutureMarketMaker", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetDoFutureMarketMaker");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetDoFutureMarketMaker");
  }

  CTAOperation_SetDoFutureMarketMaker_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetDoFutureMarketMaker", bytes);
  }

  CTAOperation_SetDoFutureMarketMaker_result result;
  try {
    result.success = iface_->SetDoFutureMarketMaker(args.atsName, args.value);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetDoFutureMarketMaker");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetDoFutureMarketMaker", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetDoFutureMarketMaker");
  }

  oprot->writeMessageBegin("SetDoFutureMarketMaker", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetDoFutureMarketMaker", bytes);
  }
}

void CTAOperationProcessor::process_SetMarketMakerCanReduce(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetMarketMakerCanReduce", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetMarketMakerCanReduce");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetMarketMakerCanReduce");
  }

  CTAOperation_SetMarketMakerCanReduce_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetMarketMakerCanReduce", bytes);
  }

  CTAOperation_SetMarketMakerCanReduce_result result;
  try {
    result.success = iface_->SetMarketMakerCanReduce(args.atsName, args.value);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetMarketMakerCanReduce");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetMarketMakerCanReduce", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetMarketMakerCanReduce");
  }

  oprot->writeMessageBegin("SetMarketMakerCanReduce", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetMarketMakerCanReduce", bytes);
  }
}

void CTAOperationProcessor::process_ForceContribe(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.ForceContribe", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.ForceContribe");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.ForceContribe");
  }

  CTAOperation_ForceContribe_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.ForceContribe", bytes);
  }

  CTAOperation_ForceContribe_result result;
  try {
    iface_->ForceContribe(args.atsName);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.ForceContribe");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ForceContribe", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.ForceContribe");
  }

  oprot->writeMessageBegin("ForceContribe", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.ForceContribe", bytes);
  }
}

void CTAOperationProcessor::process_ResetMovingAvg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.ResetMovingAvg", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.ResetMovingAvg");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.ResetMovingAvg");
  }

  CTAOperation_ResetMovingAvg_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.ResetMovingAvg", bytes);
  }

  CTAOperation_ResetMovingAvg_result result;
  try {
    iface_->ResetMovingAvg(args.atsName);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.ResetMovingAvg");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ResetMovingAvg", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.ResetMovingAvg");
  }

  oprot->writeMessageBegin("ResetMovingAvg", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.ResetMovingAvg", bytes);
  }
}

void CTAOperationProcessor::process_SetTwapData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetTwapData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetTwapData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetTwapData");
  }

  CTAOperation_SetTwapData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetTwapData", bytes);
  }

  CTAOperation_SetTwapData_result result;
  try {
    result.success = iface_->SetTwapData(args.atsName, args.data);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetTwapData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetTwapData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetTwapData");
  }

  oprot->writeMessageBegin("SetTwapData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetTwapData", bytes);
  }
}

void CTAOperationProcessor::process_SetTurtleAlgoData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetTurtleAlgoData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetTurtleAlgoData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetTurtleAlgoData");
  }

  CTAOperation_SetTurtleAlgoData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetTurtleAlgoData", bytes);
  }

  CTAOperation_SetTurtleAlgoData_result result;
  try {
    result.success = iface_->SetTurtleAlgoData(args.atsName, args.data);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetTurtleAlgoData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetTurtleAlgoData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetTurtleAlgoData");
  }

  oprot->writeMessageBegin("SetTurtleAlgoData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetTurtleAlgoData", bytes);
  }
}

void CTAOperationProcessor::process_SetKlineConfig(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetKlineConfig", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetKlineConfig");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetKlineConfig");
  }

  CTAOperation_SetKlineConfig_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetKlineConfig", bytes);
  }

  CTAOperation_SetKlineConfig_result result;
  try {
    result.success = iface_->SetKlineConfig(args.atsName, args.data);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetKlineConfig");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetKlineConfig", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetKlineConfig");
  }

  oprot->writeMessageBegin("SetKlineConfig", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetKlineConfig", bytes);
  }
}

void CTAOperationProcessor::process_SetTurtleFuture(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetTurtleFuture", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetTurtleFuture");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetTurtleFuture");
  }

  CTAOperation_SetTurtleFuture_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetTurtleFuture", bytes);
  }

  CTAOperation_SetTurtleFuture_result result;
  try {
    iface_->SetTurtleFuture(result.success, args.atsName, args.code);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetTurtleFuture");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetTurtleFuture", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetTurtleFuture");
  }

  oprot->writeMessageBegin("SetTurtleFuture", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetTurtleFuture", bytes);
  }
}

void CTAOperationProcessor::process_SetRiskDegree(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.SetRiskDegree", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.SetRiskDegree");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.SetRiskDegree");
  }

  CTAOperation_SetRiskDegree_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.SetRiskDegree", bytes);
  }

  CTAOperation_SetRiskDegree_result result;
  try {
    result.success = iface_->SetRiskDegree(args.atsName, args.RiskDegree);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.SetRiskDegree");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetRiskDegree", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.SetRiskDegree");
  }

  oprot->writeMessageBegin("SetRiskDegree", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.SetRiskDegree", bytes);
  }
}

void CTAOperationProcessor::process_MatchOrders(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("CTAOperation.MatchOrders", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "CTAOperation.MatchOrders");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "CTAOperation.MatchOrders");
  }

  CTAOperation_MatchOrders_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "CTAOperation.MatchOrders", bytes);
  }

  CTAOperation_MatchOrders_result result;
  try {
    iface_->MatchOrders();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "CTAOperation.MatchOrders");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("MatchOrders", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "CTAOperation.MatchOrders");
  }

  oprot->writeMessageBegin("MatchOrders", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "CTAOperation.MatchOrders", bytes);
  }
}

::boost::shared_ptr< ::apache::thrift::TProcessor > CTAOperationProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< CTAOperationIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< CTAOperationIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new CTAOperationProcessor(handler));
  return processor;
}

bool CTAOperationConcurrentClient::SetFutureSpreadHitStatus(const std::string& atsName, const bool status)
{
  int32_t seqid = send_SetFutureSpreadHitStatus(atsName, status);
  return recv_SetFutureSpreadHitStatus(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadHitStatus(const std::string& atsName, const bool status)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadHitStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadHitStatus_pargs args;
  args.atsName = &atsName;
  args.status = &status;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetFutureSpreadHitStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadHitStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetFutureSpreadHitStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadHitStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetFutureSpreadConStatus(const std::string& atsName, const bool status)
{
  int32_t seqid = send_SetFutureSpreadConStatus(atsName, status);
  return recv_SetFutureSpreadConStatus(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadConStatus(const std::string& atsName, const bool status)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadConStatus", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConStatus_pargs args;
  args.atsName = &atsName;
  args.status = &status;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetFutureSpreadConStatus(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadConStatus") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetFutureSpreadConStatus_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConStatus failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetFutureSpreadConBuy(const std::string& atsName, const bool status)
{
  int32_t seqid = send_SetFutureSpreadConBuy(atsName, status);
  return recv_SetFutureSpreadConBuy(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadConBuy(const std::string& atsName, const bool status)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadConBuy", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConBuy_pargs args;
  args.atsName = &atsName;
  args.status = &status;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetFutureSpreadConBuy(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadConBuy") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetFutureSpreadConBuy_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConBuy failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetFutureSpreadConSell(const std::string& atsName, const bool status)
{
  int32_t seqid = send_SetFutureSpreadConSell(atsName, status);
  return recv_SetFutureSpreadConSell(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadConSell(const std::string& atsName, const bool status)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadConSell", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConSell_pargs args;
  args.atsName = &atsName;
  args.status = &status;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetFutureSpreadConSell(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadConSell") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetFutureSpreadConSell_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConSell failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpreadFairSpread(const std::string& atsName, const double fairspread)
{
  int32_t seqid = send_SetFutureSpreadFairSpread(atsName, fairspread);
  return recv_SetFutureSpreadFairSpread(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadFairSpread(const std::string& atsName, const double fairspread)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadFairSpread", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadFairSpread_pargs args;
  args.atsName = &atsName;
  args.fairspread = &fairspread;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpreadFairSpread(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadFairSpread") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpreadFairSpread_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadFairSpread failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpreadPosShift(const std::string& atsName, const double posShift)
{
  int32_t seqid = send_SetFutureSpreadPosShift(atsName, posShift);
  return recv_SetFutureSpreadPosShift(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadPosShift(const std::string& atsName, const double posShift)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadPosShift", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadPosShift_pargs args;
  args.atsName = &atsName;
  args.posShift = &posShift;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpreadPosShift(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadPosShift") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpreadPosShift_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadPosShift failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpreadMinGainCon(const std::string& atsName, const double minGainCon)
{
  int32_t seqid = send_SetFutureSpreadMinGainCon(atsName, minGainCon);
  return recv_SetFutureSpreadMinGainCon(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadMinGainCon(const std::string& atsName, const double minGainCon)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadMinGainCon", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMinGainCon_pargs args;
  args.atsName = &atsName;
  args.minGainCon = &minGainCon;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpreadMinGainCon(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadMinGainCon") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpreadMinGainCon_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMinGainCon failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpreadMinGainHit(const std::string& atsName, const double minGainHit)
{
  int32_t seqid = send_SetFutureSpreadMinGainHit(atsName, minGainHit);
  return recv_SetFutureSpreadMinGainHit(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadMinGainHit(const std::string& atsName, const double minGainHit)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadMinGainHit", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMinGainHit_pargs args;
  args.atsName = &atsName;
  args.minGainHit = &minGainHit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpreadMinGainHit(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadMinGainHit") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpreadMinGainHit_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMinGainHit failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t CTAOperationConcurrentClient::SetFutureSpreadMinInterval(const std::string& atsName, const int32_t MinInterval)
{
  int32_t seqid = send_SetFutureSpreadMinInterval(atsName, MinInterval);
  return recv_SetFutureSpreadMinInterval(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadMinInterval(const std::string& atsName, const int32_t MinInterval)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadMinInterval", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMinInterval_pargs args;
  args.atsName = &atsName;
  args.MinInterval = &MinInterval;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t CTAOperationConcurrentClient::recv_SetFutureSpreadMinInterval(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadMinInterval") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      CTAOperation_SetFutureSpreadMinInterval_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMinInterval failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t CTAOperationConcurrentClient::SetFutureSpreadMaxWaitInterval(const std::string& atsName, const int32_t MaxWaitInterval)
{
  int32_t seqid = send_SetFutureSpreadMaxWaitInterval(atsName, MaxWaitInterval);
  return recv_SetFutureSpreadMaxWaitInterval(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadMaxWaitInterval(const std::string& atsName, const int32_t MaxWaitInterval)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadMaxWaitInterval", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMaxWaitInterval_pargs args;
  args.atsName = &atsName;
  args.MaxWaitInterval = &MaxWaitInterval;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t CTAOperationConcurrentClient::recv_SetFutureSpreadMaxWaitInterval(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadMaxWaitInterval") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      CTAOperation_SetFutureSpreadMaxWaitInterval_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMaxWaitInterval failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t CTAOperationConcurrentClient::SetFutureSpreadHitSize(const std::string& atsName, const int32_t HitSize)
{
  int32_t seqid = send_SetFutureSpreadHitSize(atsName, HitSize);
  return recv_SetFutureSpreadHitSize(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadHitSize(const std::string& atsName, const int32_t HitSize)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadHitSize", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadHitSize_pargs args;
  args.atsName = &atsName;
  args.HitSize = &HitSize;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t CTAOperationConcurrentClient::recv_SetFutureSpreadHitSize(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadHitSize") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      CTAOperation_SetFutureSpreadHitSize_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadHitSize failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t CTAOperationConcurrentClient::SetFutureSpreadConSize(const std::string& atsName, const int32_t ConSize)
{
  int32_t seqid = send_SetFutureSpreadConSize(atsName, ConSize);
  return recv_SetFutureSpreadConSize(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadConSize(const std::string& atsName, const int32_t ConSize)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadConSize", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConSize_pargs args;
  args.atsName = &atsName;
  args.ConSize = &ConSize;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t CTAOperationConcurrentClient::recv_SetFutureSpreadConSize(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadConSize") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      CTAOperation_SetFutureSpreadConSize_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConSize failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpreadConMinDiff(const std::string& atsName, const double ConMinDiff)
{
  int32_t seqid = send_SetFutureSpreadConMinDiff(atsName, ConMinDiff);
  return recv_SetFutureSpreadConMinDiff(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadConMinDiff(const std::string& atsName, const double ConMinDiff)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadConMinDiff", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConMinDiff_pargs args;
  args.atsName = &atsName;
  args.ConMinDiff = &ConMinDiff;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpreadConMinDiff(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadConMinDiff") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpreadConMinDiff_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConMinDiff failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpreadMinGainConExit(const std::string& atsName, const double MinGainConExit)
{
  int32_t seqid = send_SetFutureSpreadMinGainConExit(atsName, MinGainConExit);
  return recv_SetFutureSpreadMinGainConExit(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadMinGainConExit(const std::string& atsName, const double MinGainConExit)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadMinGainConExit", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMinGainConExit_pargs args;
  args.atsName = &atsName;
  args.MinGainConExit = &MinGainConExit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpreadMinGainConExit(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadMinGainConExit") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpreadMinGainConExit_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMinGainConExit failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpreadConMaxDistance(const std::string& atsName, const double ConMaxDistance)
{
  int32_t seqid = send_SetFutureSpreadConMaxDistance(atsName, ConMaxDistance);
  return recv_SetFutureSpreadConMaxDistance(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadConMaxDistance(const std::string& atsName, const double ConMaxDistance)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadConMaxDistance", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConMaxDistance_pargs args;
  args.atsName = &atsName;
  args.ConMaxDistance = &ConMaxDistance;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpreadConMaxDistance(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadConMaxDistance") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpreadConMaxDistance_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConMaxDistance failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t CTAOperationConcurrentClient::SetFutureSpreadFuture1Pos(const std::string& atsName, const int32_t Future1Pos)
{
  int32_t seqid = send_SetFutureSpreadFuture1Pos(atsName, Future1Pos);
  return recv_SetFutureSpreadFuture1Pos(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadFuture1Pos(const std::string& atsName, const int32_t Future1Pos)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadFuture1Pos", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadFuture1Pos_pargs args;
  args.atsName = &atsName;
  args.Future1Pos = &Future1Pos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t CTAOperationConcurrentClient::recv_SetFutureSpreadFuture1Pos(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadFuture1Pos") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      CTAOperation_SetFutureSpreadFuture1Pos_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadFuture1Pos failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t CTAOperationConcurrentClient::SetFutureSpreadFuture2Pos(const std::string& atsName, const int32_t Future2Pos)
{
  int32_t seqid = send_SetFutureSpreadFuture2Pos(atsName, Future2Pos);
  return recv_SetFutureSpreadFuture2Pos(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadFuture2Pos(const std::string& atsName, const int32_t Future2Pos)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadFuture2Pos", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadFuture2Pos_pargs args;
  args.atsName = &atsName;
  args.Future2Pos = &Future2Pos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t CTAOperationConcurrentClient::recv_SetFutureSpreadFuture2Pos(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadFuture2Pos") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      CTAOperation_SetFutureSpreadFuture2Pos_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadFuture2Pos failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t CTAOperationConcurrentClient::SetFutureSpreadMaxNumOrders(const std::string& atsName, const int32_t MaxNumOrders)
{
  int32_t seqid = send_SetFutureSpreadMaxNumOrders(atsName, MaxNumOrders);
  return recv_SetFutureSpreadMaxNumOrders(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadMaxNumOrders(const std::string& atsName, const int32_t MaxNumOrders)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadMaxNumOrders", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMaxNumOrders_pargs args;
  args.atsName = &atsName;
  args.MaxNumOrders = &MaxNumOrders;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t CTAOperationConcurrentClient::recv_SetFutureSpreadMaxNumOrders(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadMaxNumOrders") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      CTAOperation_SetFutureSpreadMaxNumOrders_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMaxNumOrders failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t CTAOperationConcurrentClient::SetFutureSpreadMaxPos(const std::string& atsName, const int32_t MaxPos)
{
  int32_t seqid = send_SetFutureSpreadMaxPos(atsName, MaxPos);
  return recv_SetFutureSpreadMaxPos(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadMaxPos(const std::string& atsName, const int32_t MaxPos)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadMaxPos", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadMaxPos_pargs args;
  args.atsName = &atsName;
  args.MaxPos = &MaxPos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t CTAOperationConcurrentClient::recv_SetFutureSpreadMaxPos(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadMaxPos") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      CTAOperation_SetFutureSpreadMaxPos_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadMaxPos failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetFutureSpreadUseMarketOrder(const std::string& atsName, const bool useMarketORder)
{
  int32_t seqid = send_SetFutureSpreadUseMarketOrder(atsName, useMarketORder);
  return recv_SetFutureSpreadUseMarketOrder(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadUseMarketOrder(const std::string& atsName, const bool useMarketORder)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadUseMarketOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadUseMarketOrder_pargs args;
  args.atsName = &atsName;
  args.useMarketORder = &useMarketORder;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetFutureSpreadUseMarketOrder(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadUseMarketOrder") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetFutureSpreadUseMarketOrder_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadUseMarketOrder failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpreadPosConvex(const std::string& atsName, const double posConvex)
{
  int32_t seqid = send_SetFutureSpreadPosConvex(atsName, posConvex);
  return recv_SetFutureSpreadPosConvex(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadPosConvex(const std::string& atsName, const double posConvex)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadPosConvex", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadPosConvex_pargs args;
  args.atsName = &atsName;
  args.posConvex = &posConvex;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpreadPosConvex(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadPosConvex") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpreadPosConvex_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadPosConvex failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetFutureSpreadIgnoreUpDnLimit(const std::string& atsName, const bool IgnoreUpDnLimit)
{
  int32_t seqid = send_SetFutureSpreadIgnoreUpDnLimit(atsName, IgnoreUpDnLimit);
  return recv_SetFutureSpreadIgnoreUpDnLimit(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadIgnoreUpDnLimit(const std::string& atsName, const bool IgnoreUpDnLimit)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadIgnoreUpDnLimit", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadIgnoreUpDnLimit_pargs args;
  args.atsName = &atsName;
  args.IgnoreUpDnLimit = &IgnoreUpDnLimit;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetFutureSpreadIgnoreUpDnLimit(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadIgnoreUpDnLimit") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetFutureSpreadIgnoreUpDnLimit_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadIgnoreUpDnLimit failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpreadConvergeRate(const std::string& atsName, const double ConvergeRate)
{
  int32_t seqid = send_SetFutureSpreadConvergeRate(atsName, ConvergeRate);
  return recv_SetFutureSpreadConvergeRate(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadConvergeRate(const std::string& atsName, const double ConvergeRate)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadConvergeRate", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadConvergeRate_pargs args;
  args.atsName = &atsName;
  args.ConvergeRate = &ConvergeRate;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpreadConvergeRate(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadConvergeRate") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpreadConvergeRate_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadConvergeRate failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpreadFastConvergeRate(const std::string& atsName, const double FastConvergeRate)
{
  int32_t seqid = send_SetFutureSpreadFastConvergeRate(atsName, FastConvergeRate);
  return recv_SetFutureSpreadFastConvergeRate(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadFastConvergeRate(const std::string& atsName, const double FastConvergeRate)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadFastConvergeRate", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadFastConvergeRate_pargs args;
  args.atsName = &atsName;
  args.FastConvergeRate = &FastConvergeRate;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpreadFastConvergeRate(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadFastConvergeRate") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpreadFastConvergeRate_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadFastConvergeRate failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpreadRatio(const std::string& atsName, const double Ratio)
{
  int32_t seqid = send_SetFutureSpreadRatio(atsName, Ratio);
  return recv_SetFutureSpreadRatio(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpreadRatio(const std::string& atsName, const double Ratio)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpreadRatio", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpreadRatio_pargs args;
  args.atsName = &atsName;
  args.Ratio = &Ratio;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpreadRatio(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpreadRatio") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpreadRatio_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpreadRatio failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::SetAtsFutureSpreadFut1(std::string& _return, const std::string& atsName, const std::string& code)
{
  int32_t seqid = send_SetAtsFutureSpreadFut1(atsName, code);
  recv_SetAtsFutureSpreadFut1(_return, seqid);
}

int32_t CTAOperationConcurrentClient::send_SetAtsFutureSpreadFut1(const std::string& atsName, const std::string& code)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetAtsFutureSpreadFut1", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetAtsFutureSpreadFut1_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_SetAtsFutureSpreadFut1(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetAtsFutureSpreadFut1") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_SetAtsFutureSpreadFut1_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetAtsFutureSpreadFut1 failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::SetAtsFutureSpreadFut2(std::string& _return, const std::string& atsName, const std::string& code)
{
  int32_t seqid = send_SetAtsFutureSpreadFut2(atsName, code);
  recv_SetAtsFutureSpreadFut2(_return, seqid);
}

int32_t CTAOperationConcurrentClient::send_SetAtsFutureSpreadFut2(const std::string& atsName, const std::string& code)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetAtsFutureSpreadFut2", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetAtsFutureSpreadFut2_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_SetAtsFutureSpreadFut2(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetAtsFutureSpreadFut2") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_SetAtsFutureSpreadFut2_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetAtsFutureSpreadFut2 failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::SetAtsFutureSpreadLastKLineTime(std::string& _return, const std::string& atsName, const std::string& KLineTime)
{
  int32_t seqid = send_SetAtsFutureSpreadLastKLineTime(atsName, KLineTime);
  recv_SetAtsFutureSpreadLastKLineTime(_return, seqid);
}

int32_t CTAOperationConcurrentClient::send_SetAtsFutureSpreadLastKLineTime(const std::string& atsName, const std::string& KLineTime)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetAtsFutureSpreadLastKLineTime", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetAtsFutureSpreadLastKLineTime_pargs args;
  args.atsName = &atsName;
  args.KLineTime = &KLineTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_SetAtsFutureSpreadLastKLineTime(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetAtsFutureSpreadLastKLineTime") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_SetAtsFutureSpreadLastKLineTime_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetAtsFutureSpreadLastKLineTime failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::SetAtsFutureSpreadKInterval(std::string& _return, const std::string& atsName, const std::string& KInterval)
{
  int32_t seqid = send_SetAtsFutureSpreadKInterval(atsName, KInterval);
  recv_SetAtsFutureSpreadKInterval(_return, seqid);
}

int32_t CTAOperationConcurrentClient::send_SetAtsFutureSpreadKInterval(const std::string& atsName, const std::string& KInterval)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetAtsFutureSpreadKInterval", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetAtsFutureSpreadKInterval_pargs args;
  args.atsName = &atsName;
  args.KInterval = &KInterval;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_SetAtsFutureSpreadKInterval(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetAtsFutureSpreadKInterval") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_SetAtsFutureSpreadKInterval_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetAtsFutureSpreadKInterval failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::CreateAutomaton(CTAAtsMsg& _return, const std::string& automatonName, const std::string& underlyingName, const std::string& subscrib_list, const std::string& feedsourcesStr, const std::string& connectionsStr)
{
  int32_t seqid = send_CreateAutomaton(automatonName, underlyingName, subscrib_list, feedsourcesStr, connectionsStr);
  recv_CreateAutomaton(_return, seqid);
}

int32_t CTAOperationConcurrentClient::send_CreateAutomaton(const std::string& automatonName, const std::string& underlyingName, const std::string& subscrib_list, const std::string& feedsourcesStr, const std::string& connectionsStr)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("CreateAutomaton", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_CreateAutomaton_pargs args;
  args.automatonName = &automatonName;
  args.underlyingName = &underlyingName;
  args.subscrib_list = &subscrib_list;
  args.feedsourcesStr = &feedsourcesStr;
  args.connectionsStr = &connectionsStr;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_CreateAutomaton(CTAAtsMsg& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("CreateAutomaton") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_CreateAutomaton_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CreateAutomaton failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::SpreadBidHitTrade(const std::string& atsName)
{
  int32_t seqid = send_SpreadBidHitTrade(atsName);
  recv_SpreadBidHitTrade(seqid);
}

int32_t CTAOperationConcurrentClient::send_SpreadBidHitTrade(const std::string& atsName)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SpreadBidHitTrade", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SpreadBidHitTrade_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_SpreadBidHitTrade(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SpreadBidHitTrade") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_SpreadBidHitTrade_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::SpreadAskHitTrade(const std::string& atsName)
{
  int32_t seqid = send_SpreadAskHitTrade(atsName);
  recv_SpreadAskHitTrade(seqid);
}

int32_t CTAOperationConcurrentClient::send_SpreadAskHitTrade(const std::string& atsName)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SpreadAskHitTrade", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SpreadAskHitTrade_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_SpreadAskHitTrade(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SpreadAskHitTrade") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_SpreadAskHitTrade_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::SpreadBidConTrade(const std::string& atsName)
{
  int32_t seqid = send_SpreadBidConTrade(atsName);
  recv_SpreadBidConTrade(seqid);
}

int32_t CTAOperationConcurrentClient::send_SpreadBidConTrade(const std::string& atsName)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SpreadBidConTrade", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SpreadBidConTrade_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_SpreadBidConTrade(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SpreadBidConTrade") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_SpreadBidConTrade_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::SpreadAskConTrade(const std::string& atsName)
{
  int32_t seqid = send_SpreadAskConTrade(atsName);
  recv_SpreadAskConTrade(seqid);
}

int32_t CTAOperationConcurrentClient::send_SpreadAskConTrade(const std::string& atsName)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SpreadAskConTrade", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SpreadAskConTrade_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_SpreadAskConTrade(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SpreadAskConTrade") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_SpreadAskConTrade_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetKeepOrders(const std::string& atsName, const bool keepOrders)
{
  int32_t seqid = send_SetKeepOrders(atsName, keepOrders);
  return recv_SetKeepOrders(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetKeepOrders(const std::string& atsName, const bool keepOrders)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetKeepOrders", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetKeepOrders_pargs args;
  args.atsName = &atsName;
  args.keepOrders = &keepOrders;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetKeepOrders(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetKeepOrders") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetKeepOrders_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetKeepOrders failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetForceOpen(const std::string& atsName, const bool forceOpen)
{
  int32_t seqid = send_SetForceOpen(atsName, forceOpen);
  return recv_SetForceOpen(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetForceOpen(const std::string& atsName, const bool forceOpen)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetForceOpen", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetForceOpen_pargs args;
  args.atsName = &atsName;
  args.forceOpen = &forceOpen;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetForceOpen(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetForceOpen") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetForceOpen_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetForceOpen failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpeedConvergeRate(const std::string& atsName, const double SpeedConvergeRate)
{
  int32_t seqid = send_SetFutureSpeedConvergeRate(atsName, SpeedConvergeRate);
  return recv_SetFutureSpeedConvergeRate(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpeedConvergeRate(const std::string& atsName, const double SpeedConvergeRate)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpeedConvergeRate", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpeedConvergeRate_pargs args;
  args.atsName = &atsName;
  args.SpeedConvergeRate = &SpeedConvergeRate;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpeedConvergeRate(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpeedConvergeRate") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpeedConvergeRate_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpeedConvergeRate failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureSpeed(const std::string& atsName, const double Speed)
{
  int32_t seqid = send_SetFutureSpeed(atsName, Speed);
  return recv_SetFutureSpeed(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureSpeed(const std::string& atsName, const double Speed)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureSpeed", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureSpeed_pargs args;
  args.atsName = &atsName;
  args.Speed = &Speed;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureSpeed(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureSpeed") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureSpeed_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureSpeed failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetFutureLastSpread(const std::string& atsName, const double LastSpread)
{
  int32_t seqid = send_SetFutureLastSpread(atsName, LastSpread);
  return recv_SetFutureLastSpread(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetFutureLastSpread(const std::string& atsName, const double LastSpread)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetFutureLastSpread", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetFutureLastSpread_pargs args;
  args.atsName = &atsName;
  args.LastSpread = &LastSpread;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetFutureLastSpread(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetFutureLastSpread") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetFutureLastSpread_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetFutureLastSpread failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetVolatility(const std::string& atsName, const double Vol)
{
  int32_t seqid = send_SetVolatility(atsName, Vol);
  return recv_SetVolatility(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetVolatility(const std::string& atsName, const double Vol)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetVolatility", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetVolatility_pargs args;
  args.atsName = &atsName;
  args.Vol = &Vol;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetVolatility(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetVolatility") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetVolatility_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetVolatility failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetMaxVolRange(const std::string& atsName, const double MaxVolRange)
{
  int32_t seqid = send_SetMaxVolRange(atsName, MaxVolRange);
  return recv_SetMaxVolRange(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetMaxVolRange(const std::string& atsName, const double MaxVolRange)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetMaxVolRange", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetMaxVolRange_pargs args;
  args.atsName = &atsName;
  args.MaxVolRange = &MaxVolRange;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetMaxVolRange(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetMaxVolRange") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetMaxVolRange_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetMaxVolRange failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetMarketMakerActive(const std::string& atsName, const std::string& code, const bool active)
{
  int32_t seqid = send_SetMarketMakerActive(atsName, code, active);
  return recv_SetMarketMakerActive(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetMarketMakerActive(const std::string& atsName, const std::string& code, const bool active)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetMarketMakerActive", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetMarketMakerActive_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.active = &active;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetMarketMakerActive(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetMarketMakerActive") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetMarketMakerActive_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetMarketMakerActive failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetMarketMakerDouble(const std::string& atsName, const std::string& code, const std::string& param, const double value)
{
  int32_t seqid = send_SetMarketMakerDouble(atsName, code, param, value);
  return recv_SetMarketMakerDouble(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetMarketMakerDouble(const std::string& atsName, const std::string& code, const std::string& param, const double value)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetMarketMakerDouble", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetMarketMakerDouble_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.param = &param;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetMarketMakerDouble(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetMarketMakerDouble") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetMarketMakerDouble_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetMarketMakerDouble failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t CTAOperationConcurrentClient::SetMarketMakerInt(const std::string& atsName, const std::string& code, const std::string& param, const int32_t value)
{
  int32_t seqid = send_SetMarketMakerInt(atsName, code, param, value);
  return recv_SetMarketMakerInt(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetMarketMakerInt(const std::string& atsName, const std::string& code, const std::string& param, const int32_t value)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetMarketMakerInt", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetMarketMakerInt_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.param = &param;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t CTAOperationConcurrentClient::recv_SetMarketMakerInt(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetMarketMakerInt") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      CTAOperation_SetMarketMakerInt_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetMarketMakerInt failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetDoFutureMarketMaker(const std::string& atsName, const bool value)
{
  int32_t seqid = send_SetDoFutureMarketMaker(atsName, value);
  return recv_SetDoFutureMarketMaker(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetDoFutureMarketMaker(const std::string& atsName, const bool value)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetDoFutureMarketMaker", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetDoFutureMarketMaker_pargs args;
  args.atsName = &atsName;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetDoFutureMarketMaker(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetDoFutureMarketMaker") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetDoFutureMarketMaker_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetDoFutureMarketMaker failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetMarketMakerCanReduce(const std::string& atsName, const bool value)
{
  int32_t seqid = send_SetMarketMakerCanReduce(atsName, value);
  return recv_SetMarketMakerCanReduce(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetMarketMakerCanReduce(const std::string& atsName, const bool value)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetMarketMakerCanReduce", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetMarketMakerCanReduce_pargs args;
  args.atsName = &atsName;
  args.value = &value;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetMarketMakerCanReduce(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetMarketMakerCanReduce") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetMarketMakerCanReduce_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetMarketMakerCanReduce failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::ForceContribe(const std::string& atsName)
{
  int32_t seqid = send_ForceContribe(atsName);
  recv_ForceContribe(seqid);
}

int32_t CTAOperationConcurrentClient::send_ForceContribe(const std::string& atsName)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("ForceContribe", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_ForceContribe_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_ForceContribe(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("ForceContribe") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_ForceContribe_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::ResetMovingAvg(const std::string& atsName)
{
  int32_t seqid = send_ResetMovingAvg(atsName);
  recv_ResetMovingAvg(seqid);
}

int32_t CTAOperationConcurrentClient::send_ResetMovingAvg(const std::string& atsName)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("ResetMovingAvg", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_ResetMovingAvg_pargs args;
  args.atsName = &atsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_ResetMovingAvg(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("ResetMovingAvg") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_ResetMovingAvg_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetTwapData(const std::string& atsName, const TWAPDataMsg& data)
{
  int32_t seqid = send_SetTwapData(atsName, data);
  return recv_SetTwapData(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetTwapData(const std::string& atsName, const TWAPDataMsg& data)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetTwapData", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetTwapData_pargs args;
  args.atsName = &atsName;
  args.data = &data;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetTwapData(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetTwapData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetTwapData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetTwapData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetTurtleAlgoData(const std::string& atsName, const TurtleAlgoMsg& data)
{
  int32_t seqid = send_SetTurtleAlgoData(atsName, data);
  return recv_SetTurtleAlgoData(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetTurtleAlgoData(const std::string& atsName, const TurtleAlgoMsg& data)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetTurtleAlgoData", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetTurtleAlgoData_pargs args;
  args.atsName = &atsName;
  args.data = &data;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetTurtleAlgoData(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetTurtleAlgoData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetTurtleAlgoData_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetTurtleAlgoData failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool CTAOperationConcurrentClient::SetKlineConfig(const std::string& atsName, const KlineConfigMsg& data)
{
  int32_t seqid = send_SetKlineConfig(atsName, data);
  return recv_SetKlineConfig(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetKlineConfig(const std::string& atsName, const KlineConfigMsg& data)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetKlineConfig", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetKlineConfig_pargs args;
  args.atsName = &atsName;
  args.data = &data;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool CTAOperationConcurrentClient::recv_SetKlineConfig(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetKlineConfig") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      CTAOperation_SetKlineConfig_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetKlineConfig failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::SetTurtleFuture(std::string& _return, const std::string& atsName, const std::string& code)
{
  int32_t seqid = send_SetTurtleFuture(atsName, code);
  recv_SetTurtleFuture(_return, seqid);
}

int32_t CTAOperationConcurrentClient::send_SetTurtleFuture(const std::string& atsName, const std::string& code)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetTurtleFuture", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetTurtleFuture_pargs args;
  args.atsName = &atsName;
  args.code = &code;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_SetTurtleFuture(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetTurtleFuture") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_SetTurtleFuture_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetTurtleFuture failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

double CTAOperationConcurrentClient::SetRiskDegree(const std::string& atsName, const double RiskDegree)
{
  int32_t seqid = send_SetRiskDegree(atsName, RiskDegree);
  return recv_SetRiskDegree(seqid);
}

int32_t CTAOperationConcurrentClient::send_SetRiskDegree(const std::string& atsName, const double RiskDegree)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetRiskDegree", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_SetRiskDegree_pargs args;
  args.atsName = &atsName;
  args.RiskDegree = &RiskDegree;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

double CTAOperationConcurrentClient::recv_SetRiskDegree(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetRiskDegree") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      double _return;
      CTAOperation_SetRiskDegree_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetRiskDegree failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void CTAOperationConcurrentClient::MatchOrders()
{
  int32_t seqid = send_MatchOrders();
  recv_MatchOrders(seqid);
}

int32_t CTAOperationConcurrentClient::send_MatchOrders()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("MatchOrders", ::apache::thrift::protocol::T_CALL, cseqid);

  CTAOperation_MatchOrders_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void CTAOperationConcurrentClient::recv_MatchOrders(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("MatchOrders") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      CTAOperation_MatchOrders_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

} // namespace

